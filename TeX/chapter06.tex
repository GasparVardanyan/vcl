\chapter{Զանգվածներ և կրկնություններ}

Ստրուկտուրաները հնարավորություն են տալիս սահմանելու տարբեր տիպերի դաշտեր
ունեցող բաղադրյալ օբյեկտներ։ Հաճախ նաև պետք է լինում սահմանել տարրերի նույն
տիպն ունեցող բաղադրյալ օբյեկտներ՝ զանգվածներ։ Այս զրույցը C լեզվի զանգվածների
և հաշվիչով ցիկլի մասին է։

\emph{Զանգվածը} նույն անունն ունեցող միատեսակ տարրերի անընդհատ շարք է։
Դրա մի որևէ տարրին կարելի է դիմել \emph{ինդեքսավորման} գործողությամբ,
զրոյից սկսվող ինդեքսի միջոցով։ Օրինակ, եթե \ident{a}-ն \ident{N} տարրեր
ունեցող զանգված է, ապա նրա առաջին տարրին կարելի է դիմել \Verb|a[0]|
գրառմամբ, իսկ վերջին տարրին՝ \Verb|a[N-1]| գրառմամբ։ Սի լեզվում որևէ տիպի
օբյեկտների զանգվածը հայտարավում է փոփոխականի անունից հետո \Verb|[| և
\Verb|]| փակագծերում տարրերի քանակը նշելով։

![զանգված](nacl-fig-2.png)

Օրինակ, առանց նշանի ամբողջ թվերի տաս տարրերից բաղկացած զանգված կարող ենք
սահմանել հետևյալ հրամանով.

\begin{Verbatim}
unsigned int v0[10];
\end{Verbatim}

Զանգվածը հայտարարելիս կարելի է միանգամից արժեքավորել նրա տարրերը։ Օրինակ.

\begin{Verbatim}
int v1[5] = { 1, 2, 3, 4, 5 };
\end{Verbatim}

Այս հրամանով սահմանված է հինգ ամբողջ թվերի զանգված, և տարրերն արժեքավորված
են \(1..5\) միջակայքի թվերով։

Համանման ձևով են սահմանվում նաև բազմաչափ զանգվածները։ Օրինակ, \(2\times 3\)
չափի մատրիցը կարելի է սահմանել ու արժեքավորել այսպես.

\begin{Verbatim}
double m0[2][3] = { {1.1, 1.2, 1.3}, {2.2, 2.3, 2.4} };
\end{Verbatim}

Եթե զանգվածը սահմանելիս արժեքավորման ցուցակում տրված են ավելի քիչ արժեքներ,
քան զանգվածի չափն է, ապա պակասող արժեքների փոխարեն զանգվածում գրվում են
զրոներ։ Օրինակ, հետևյալ սահմանումից հետո եթե վերցնեմ \ident{v2} զանգվածի
հինգերորդ տարրը, ապա կտեսնեմ, որ այն զրո է։

\begin{Verbatim}
long double v2[10] = { 1.2, 2.3 };
\end{Verbatim}

Պակասող տարրերը զրոներով արժեքավորելու հատկությունը օգտակար է զանգվածներին
սկզբնական արժեքներ տալիս։ Անորոշություններից խուսափելու համար միշտ խորհուրդ
է տրվում նոր սահմանվող զանգվածը արժեքավորել \Verb|{ 0 }| արտահայտությամբ։
Ահա այսպես.

\begin{Verbatim}
unsigned int v3[128] = { 0 };
\end{Verbatim}


Սի լեզվում զանգվածի անունը \emph{ցուցիչ} է իր առաջին տարրին, իսկ զանգվածի
տարրերին կարելի է դիմել ոչ միայն \Verb|[]| գործողությամբ, այլ նաև ցուցիչների
հետ թվաբանական գործողություններ կատարելով։ Օրինակ, \ident{v1} զանգվածի
երրորդ տարրն արտածելու համար կարող ենք գրել հետևյալ երկու համարժեք հրամանները.

\begin{Verbatim}
printf( "%d\n", v1[2] );
printf( "%d\n", *(v1 + 2) );
\end{Verbatim}


Զանգվածների հետ աշխատանքը ցուցադրելու համար ուզում եմ բերել մի օրինակ՝
նորից օգտագործելով դեկարտյան կետը։ Ենթադրենք դեկարտյան կետերի \ident{ps}
զանգվածը պարունակում է հարթության վրա ցրված \ident{N} հատ կետեր։ Պետք է
գրել մի ֆունկցիա, որը վերադարձնում է տրված կետերը որպես գագաթներ ունեցող
բեկյալի երկարությունը։

Հիշեցնեմ \ident{point} ստրուկտուրայի հայտարարությունը.

\begin{Verbatim}
struct point {
  double x;
  double y;
};
\end{Verbatim}

Բեկյալի երկարությունը նրա հանգույցների երկարությունների գումարն է։ Ամեն
մի հանգույցի երկարությունը նրա ծայրակետերի հեռավորությունն է, որը հաշվում
եմ Պյութագորասի բանաձևով։

\begin{Verbatim}
double distance( struct point a, struct point b )
{
  double dx = a.x - b.x;
  double dy = a.y - b.y;
  return sqrt( dx * dx + dy * dy );
}
\end{Verbatim}

Բեկյալի երկարությունը հաշվող \ident{length} ֆունկցիան կարող է ունենալ
հետևյալ հայտարարությունը.

\begin{Verbatim}
double length( const struct point[], int );
\end{Verbatim}

Սա նշանակում է, որ \ident{length} անունով ֆունկցիան արգումենտում սպասում
է \texttt{struct point} օբյեկտների զանգված և մի ամբողջ թիվ, որը զանգվածի
տարրերի քանակն է։ Ֆունկցիայի վերադարձրած \kw{double} արժեքն էլ բեկյալի
երկարությունն է։ \kw{const} ծառայողական բառը ցույց է տալիս, որ զանգվածը
ֆունկցիային է փոխանցվել որպես \emph{հաստատուն}. նրա արժեքները կարելի է
միայն կարդալ (read-only), բայց չի կարելի փոփոխել։

Ի դեպ, քանի որ զանգվածի անունն իր առաջին տարրի ցուցիչն է, վերը բերված
հայտարարությունը կարող է ունենալ նաև հետևյալ համարժեք տեսքը.

\begin{Verbatim}
double length( const struct point*, int );
\end{Verbatim}

\(N\) գագաթներ (\(N-1\) հանգույցներ) ունեցող բեկյալի երկարությունը ես
կհաշվեմ ռեկուրսիվ եղանակով՝ ըստ գագաթների քանակի։ Եթե զանգվածում մեկ
տարր է, ապա բեկյալը հանգույցներ չունի և նրա երկարությունը զրո է։ Եթե
բեկյալն ունի \(n\) գագաթներ, ապա նրա երկարությունը հավասար է \(n-1\)-րդ
և \(n\)-րդ գագաթների հեռավորությանը գումարած առաջին \(n-1\) գագաթներից
կազմված բեկյալի երկարությունը։

\begin{Verbatim}
double length( const struct point ps[], int nm )
{
  if( nm == 1 )
    return 0.0;
  return distance( ps[nm-1], ps[nm-2] )
       + length( ps, nm-1 );
}
\end{Verbatim}

Կարծես թե ճիշտ է, բայց ստուգելը չի խանգարի։ Սահմանեմ մի վեկտոր, որը
պարունակում է \(f(x)=x\) ուղղին պատկանող \((0,0)\), \((1,1)\),
\((2,2)\) և \((3,3)\) կետերը, ապա հաշվեմ ու արտածեմ այդ կետերով կազմված
բեկյալի (ուղիղ գծի) երկարությունը։

\begin{Verbatim}
int main()
{
  struct point ps[] = { {0,0}, {1,1}, {2,2}, {3,3} };
  double res = length( ps, 4 );
  printf( ">> %lf\n", res );
  return 0;
}
\end{Verbatim}

\ident{points} զանգվածը սահմանելիս ես նրա չափը բացահայտ չեմ նշել։ Եթե
առկա է զանգվածն արժեքավորող ցուցակ, ապա կոմպիլյատորը զանգվածի չափը պարզում
է այդ ցուցակում տրված արժեքների քանակով։ Տվյալ դեպքում թվարկված են չորս
կետի կոորդինատներ, հետևաբար \ident{points} զանգվածի չափը \(4\) է։


Զանգվածի տարրերին հաջորդաբար դիմելու ամենահարմար միջոցը Սի լեզվի \kw{for}
կրկնման հրամանն է։ Այս \kw{for} հրամանը հիմնականում օգտագործվում է
\emph{հաշվիչով կրկնություններ} կազմակերպելու համար։

\begin{Verbatim}
for( ⟨հաշվիչի արժեքավորում⟩; ⟨կրկնման պայման⟩; ⟨հաշվիչի փոփոխում⟩ )
  ⟨կատարվող մարմին⟩
\end{Verbatim}

Նախ՝ հաշվարկվում է \stoken{հաշվիչի արժեքավորում} արտահայտությունը, որով
սահմանվում և սկզբնական արժեք է ստանում ցիկլի հաշվիչը։ Այնուհետև, քանի
դեռ \emph{կեղծ է} \stoken{կրկնման պայման} արտահայտության արժեքը, կատարվում
են ցիկլի \stoken{կատարվող մարմին} բլոկի հրամանները։ Ցիկլի մարմնի հրամանների
կատարումից հետո հաշվարկվում է \stoken{հաշվիչի փոփոխում} արտահայտությունը,
որը նախատեսված է ցիկլի հաշվիչը ինչ-որ կանոնով փոփոխելու (ավելացնելու կամ
պակասեցնելու) համար։

Օրինակ, եթե պետք լինի գտնել իրական թվերի զանգվածի ամենամեծ տարրը, ապա կարող
եմ գրել հետևյալ ֆունկցիան.

\begin{Verbatim}
double amax( const double arr[], int num )
{
  double max = arr[0];
  for( int k = 1; k < num; ++k )
    if( max < arr[k] )
      max = arr[k];
  return max;
}
\end{Verbatim}

\ident{amax} ֆունկցիայի \kw{for} հրամանում \texttt{int k = 1} արտահայտությամբ
սահմանվել է \ident{k} հաշվիչը և նրան տրվել է \(1\) սկզբնական արժեքը։ Այդ
\kw{for} հրամանում որպես ցիկլի ավարտի պայման է նշված \texttt{k < num}
արտահայտությունը։ Սա նշանակում է, որ ցիկլը կկատարվի այնքան անգամ, քանի դեռ
\ident{k}-ն փոքր է \ident{num}-ից։ Նույն \kw{for} հրամանում \ident{k}
հաշվիչը փոփոխվում է \Verb|++k| արտահայտությամբ, որը ցիկլի ամեն մի
իտերացիայից հետո \ident{k}-ի արժեքն ավելացնում է մեկով։

Արժեքի \emph{ավելացման} \Verb|++| (increment) գործողությունը Սի լեզվում
հանդես է գալիս \emph{նախածանցային} (prefix) և \emph{վերջածանցային}
(postfix) տեսքերով։ Օրինակ, կարելի է գրել և՛ \Verb|++k|, և՛ \Verb|k++|։
Առաջին դեպքում արտահայտության արժեքը \ident{k}-ի նոր արժեքն է, իսկ երկրորդ
դեպքում՝ հինը։ Օրինակ, կարող եմ սահմանել \ident{inc\_pr} և \ident{inc\_po}
ֆունկցիաները, որոնցից առաջինը համարժեք է \Verb|++| գործողության նախածանցային
տարբերակին, իսկ երկրորդը՝ վերջածանցային տարբերակին։

\begin{Verbatim}
/* նախածանցային ինկրեմենտի մոդելը */
int inc_pr( int* var )
{
  *var = *var + 1;
  return var;
}

/* վերջածանցային ինկրեմենտի մոդելը */
int inc_po( int* var )
{
  int old = *var;
  *var = *var + 1;
  return old;
}
\end{Verbatim}

\Verb|++| գործողության նմանությամբ C լեզուն տրամադրում է նաև արժեքի
\emph{նվազեցման} \Verb|--| (decrement) գործողությունը։ Սա նույնպես հանդես
է գալիս նախածանցային ու վերջածանցային տարբերակներով։


Բեկյալի երկարությունը հաշվող \emph{length} ֆունկցիան, որ սահմանեցի վերևում,
նույնպես կարող եմ գրել \kw{for} ցիկլի օգնությամբ։ [Բայց պիտի ասեմ, որ
ռեկուրսիվ իրականացումն ինձ ավելի \emph{գեղեցիկ} է թվում։]

\begin{Verbatim}
double length( struct point ps[], int nm )
{
  double result = 0.0;
  for( int j = 1; j < nm; ++j )
    result += distance( ps[j-1], ps[j] ) ;
  return result;
}
\end{Verbatim}

Այս ֆունկցիայի \kw{for} հրամանի մարմնում օգտագործված \Verb|+=| գործողությունն
իր աջ կողմում գրված արտահայտության արժեքը ավելացնում է ձախ կողմում գրված
փոփոխականին։ Ավելի պարզ ասած՝ \hbox{\stoken{var} \Verb|+=| \stoken{val}}
արտահայտությունը համարժեք է
\hbox{\stoken{var} \Verb|=| \stoken{var} \Verb|+| \stoken{val}}
արտահայտությանը։ Նույն տիպի «կրճատ» վերագրման տարբերակներ կան նաև հանման՝
\Verb|-=|, բազմապատկման՝ \Verb|*=|, բաժանման՝ \Verb|/=| և այլ
գործողությունների համար։

Եվս մի օրինակ, ու վերջացնեմ զանգվածների մասին զրույցը։ Գրեմ մի ֆունկցիա,
որը տրված իրական թվերի միաչափ զանգվածի տարրերը դասավորում է հակառակ կարգով։

\begin{Verbatim}
void areverse( double arr[], int nm )
{
  for( int b = 0, e = nm - 1; b < e; ++b, --e ) {
    double temp = arr[b];
    arr[b] = arr[e];
    arr[e] = temp;
  }
}
\end{Verbatim}

\kw{for} հրամանում սահմանվել են երկու հաշվիչներ՝ \ident{b}, որը «շարժվում»
է զանգվածի սկզբից դեպի վերջը, և \ident{e}, որը «շարժվում» է վերջից դեպի
սկիզբը։ Ցիկլը կատարվում է այնքան անգամ, քանի դեռ զանգվածի \ident{b} ինդեքսը
փոքր է \ident{e} ինդեքսից։ Ցիկլի ամեն մի իտերացիայից հետո \ident{b} ինդեքսն
աճում է, իսկ \ident{e}-ն՝ նվազում։ \Verb|++b, --c| արտահայտության մեջ
նույնպես օգտագործված է \Verb|,| (ստորակետ) \emph{թվարկման} գործողությունը։
Դե իսկ ցիկլի մարմնում, որն այս դեպքում բաղկացած է երեք հրամաններից, կատարվում
է արժեքների տեղափոխությունը՝ \ident{b}-րդ տարրը գրվում \ident{e}-րդի փոխարեն
և հակառակը։ Հենց այն պատճառով, որ \kw{for} հրամանի մարմնում մի քանի հրամաններ
են, մարմինը վերցրած է \Verb|{| նիշով սկսվող և \Verb|}| նիշով ավարտվող
\emph{բլոկի} մեջ։ Պետք է նշել, որ բլոկում սահմանված փոփոխականը \emph{լոկալ}
է՝ տեսանելի է միայն բլոկի մարմնում։

Ես ուզում էի այս օրինակով ավարտել զանգվածների ու պարամետրով ցիկլի մասին
զրույցը, բայց խոսքը խոսք բերեց ու ես որոշեցի գրել \ident{areverse}
ֆունկցիայի մի այլ տարբերակ։ \ident{areversep} ֆունկցիայում, զանգվածի
տարրերին դիմելիս, ինդեքսների փոխարեն օգտագործում եմ ցուցիչներ։

\begin{Verbatim}
void areversep( double* arr, int nm )
{
  for( double *p = arr, *q = arr + nm - 1; p < q; ++p, --q ) {
    double temp = *p;
    *p = *q;
    *q = temp;
  }
}
\end{Verbatim}

Արդեն ասել եմ, որ Սի լեզվի կոմպիլյատորը զանգվածի անունը համարում է ցուցիչ
նրա առաջին տարրին։ Դա հաշվի առնելով \ident{areversep} ֆունկցիայի \ident{arr}
պարամետրը նկարագրել եմ որպես \Verb|double*|։ Այնուհետև՝ \kw{for} հրամանի
հաշվիչները սահմանում եմ ոչ թե որպես զանգվածի ինդեքսներ, այլ որպես նրա տարրերի
ցուցիչներ. \ident{p}-ն ստանում է նույն \ident{arr} սկզբնական արժեքը, իսկ
\ident{q}-ն՝ \Verb|arr + nm - 1| արժեքը, որը զանգվածի վերջին տարրի հասցեն է։
Ցիկլը կատարվում է, քանի դեռ \ident{p} հասցեն փոքր է \ident{q} հասցեից։ Սի
լեզվում երկու ցուցիչների համեմատությունն իմաստալից է միայն այն դեպքում, եթե
դրանք ցույց են տալիս միևնույն զանգվածի տարրերին։ \Verb|++| և \Verb|--|
գործողությունները նույնպես թույլատրելի են ցուցիչների նկատմամբ։ \Verb|++|-ը
ցուցիչը տեղափոխում է իրեն հաջորդող տարրին, իսկ \Verb|--|-ը՝ իրեն նախորդող
տարրին։
