\chapter{Առաջին ծրագիրը}

\begin{quote}
\emph{Սի լեզվով գրված առաջին ծրագիրը, դրա խմբագրումը, թարգմանումը և կատարումը։}
\end{quote}

Մի հայտնի ու իմաստուն գրքում (K\&R, \cite{krc}) ասվում է, որ ծրագրավորման լեզուն սովորելու ամենալավ եղանակը դրանով ծրագրեր գրելն է։ Ես հետևում եմ այդ խորհրդին ու Սի լեզվի մասին առաջին իմ \emph{զրույցը} սկսում եմ մի կարճ ծրագրով։ Այն պետք է արտածման ստանդարտ հոսքին դուրս բերի երկու տող՝ «Ողջո՜ւյն։» և «Այդ ե՛ս եմ՝ քո առաջին Սի ծրագիրը։»։

Բայց... եկեք չշտապենք ու նախ տեսնենք, թե ինչ «կյանք է ապրում» ծրագիրը մտահաղացումից մինչև իրականացում ու կատարում։

Եվ այսպես. պետք է Սի լեզվով գրենք ծրագիր, որն արտածում է տեքստի երկու տող. սա մտահաղացումն է։

\begin{Verbatim}
/* Առաջին ծրագիրը */
#include <stdio.h>

int main()
{
    puts("Ողջո՜ւյն։");
    puts("Այդ ե՛ս եմ՝ քո առաջին Սի ծրագիրը։");
    return 0;
}
\end{Verbatim}

Առաջին տողում գրված \verb|/*| նիշերով սկսվող և \verb|*/| նիշերով ավարտվող տեքստը \emph{մեկնաբանություն} է։ Մեկնաբանությունները նախատեսված են մարդկանց համար․ դրանք ամբողջությամբ անտեսվում են կոմպիլյատորի կողմից։ Սի լեզվում մեկնաբանություններ կարելի է գրել նաև C++ լեզվից փոխանցված եղանակով. այդպիսի մեկնաբանությունները սկսվում են \verb|//| նիշերով և տարածվում են մինչև տողի վերջը։

Երկրորդ տողի \verb|#include <stdio.h>| արտահայտությունը պահանջում է կոմպիլյացիայից առաջ \texttt{prog01.c} ֆայլին կցել գրադարանային \texttt{stdio.h} ֆայլը։ Այն պարունակում է տվյալների ներմուծման ու արտածման համար նախատեսված ստանդարտ ֆունկցիաների, կառուցվածքների և այլ ծրագրային բաղադրիչների հայտարարությունները։ Առաջ անցնելով նշենք, որ \verb|#| նիշով սկսվող բոլոր հրահանգները նախատեսված են \emph{նախապրոցեսորի} (\emph{preprocessor}) համար, և Սի լեզվի մաս չեն կազմում. այս մասին քիչ ավելի ուշ։

Չորրորդ տողում գրված է Սի ծրագրերի \emph{մուտքի կետ}՝ կատարման սկիզբ, հանդիսացող \texttt{main} ֆունկցիայի վերնագիրը։ Տվյալ դեպքում \texttt{main} ֆունկցիան արգումենտներ չի սպասում՝ նրա արգումենտների ցուցակը դատարկ է, բայց վերադարձնում է \texttt{int} (integer, ամբողջ թիվ) տիպի արժեք։ Սի լեզվով գրված բոլոր ծրագրերն իրենց աշխատանքը սկսում են հենց \texttt{main} ֆունկցիայից։ Ավելի պատկերավոր ասած՝ \texttt{main} ֆունկցիան կանչվում է օպերացիոն համակարգի կողմից, իսկ նրա վերադարձրած արժեքը օպերացիոն համակարգը մեկնաբանում է որպես կատարվող ծրագրի հաջող կամ անհաջող ավարտի հայտանիշ։ Պայմանավորվածություն կա, որ \texttt{0} արժեք են վերադարձնում հաջող ավարտված ծրագրերը, իսկ զրոյից տարբեր արժեք՝ անհաջող ավարտվածները։

Սի ֆունկցիայի \emph{մարմինը}՝ այն հրամանների հաջորդականությունը, որոնցով որոշվում է ֆունկցիայի վարքը, պարփակված է ֆունկցիայի վերնագրին հաջորդող \verb|{| և \verb|}| փակագծերի մեջ։ Մեր օրինակի հինգերորդ տողում սկսվում է և իներորդ տողում ավարտվում է \texttt{main} ֆունկցիայի մարմինը։

Վեցերորդ և յոթերորդ տողերում օգտագործված է \texttt{stdio} (standard input-output) գրադարանի \texttt{puts} (put string — արտածել տողը) ֆունկցիան։ Այն իր արգումենտում ստանում է նիշերի տող և այդ տողն արտածում է \texttt{stdout} արտածման ստանդարտ հոսքին։

Ութերորդ տողում օգտագործված \texttt{return} հրամանը նախատեսված է ֆունկցիայից արժեք վերադարձնելու համար (սրա մասին դեռ շատ կխոսենք)։ Այստեղ \texttt{return} հրամանով \texttt{main} ֆունկցիան վերադարձնում է \texttt{0} արժեքը, որը, ինչպես արդեն նշեցինք, ցուց է տալիս ծրագրի՝ այդ կետում հաջող ավարտված լինելը։

Վերջապես նկատենք նաև, որ բոլոր հրամաններն ավարտվում են \verb|;| (կետ-ստորակետ) նիշով։

Հիմա փորձենք «կյանք տալ» այս ծրագրին. այսինքն՝ թարգմանել այն մեքենայական լեզվի ու կատարել։ Դրա համար տեսնենք թե ինչ կյանք է ապրում ծրագիրը՝ մտահաղացումից մինչև կատարում։

Ժամանակակից ծրագրավորողը քոմփյութերային ծրագրերի մշակման ընթացքում կատարում է հետևյալ հիմնական քայլերը.

\emph{Ծրագրի տեքստի խմբագրում} (editing) --- մի որևէ տեքստային խմբագրիչով, կամ ծրագրերի մշակման ինտեգրացված միջավայրում (IDE, integrated development environment) ստեղծվում է ծրագրի տեքստը և պահպանվում է ֆայլի մեջ։ Սի լեզվով գրված ծրագրերի ֆայլերը հիմնականում ունենում են \texttt{.c} վերջավորություն, իսկ հայտարարությունների ֆայլերը՝ \texttt{.h} վերջավորություն։

Տվյալ դեպքում տեքստային խմբագրիչում ներմուծում եմ վերը բերված ծրագրի տեքստը և այն պահպանում եմ \texttt{prog01.c} անունով ֆայլում։

![տեքստային-խմբագրիչի-նկար](vcl-editor.png)

\emph{Թարգմանություն} կամ \emph{կոմպիլյացիա} (compilation) --- թարգմանող ծրագրի՝ \emph{կոմպիլյատորի} միջոցով ծրագրի տեքստային ներկայացումից կառուցվում է կոնկտրետ սարքակազմի վրա և կոնկրետ օպերացիոն համակարգում աշխատող, մեքենայական կոդը պարունակող \emph{կատարվող մոդուլը} (executable module)։

Ծրագրի \texttt{prog01.c} ֆայլը (source file) թարգմանում եմ այսպես.

\begin{verbatim}
$ cc prog01.c -o prog01
\end{verbatim}

Այս հրամանում կոմպիլյատորին տրվող \verb|-o| պարամետրի արգումենտով որոշվում է ստեղծվելիք կատարվող մոդուլի անունը։ \verb|-o| պարամետրի բացակայության դեպքում կոմպիլյատորը կստեղծի \verb|a.out| անունով կատարվող ֆայլ։ Եթե ծրագրի տեքստը սխալներ չի պարունակում, և կոմպիլյացիան հաջող է անցնում, ապա ստեղծվում է \verb|prog01| կատարվող մոդուլը։

\emph{Թեսթավորում} (testing) և \emph{կատարում} (execution) --- օպերացիոն համակարգը կատարվող մոդուլը բեռնում է մեքենայի հիշողության մեջ և սկսում է կատարել այն։ Ինչպես արդեն նշվեց վերեւում, կատարումը սկսվում է \texttt{main} ֆունկցիայից։ Թեսթավորման ժամանակ ծրագիրը կատարվում է նախապես որոշված տվյալներով ու սցենարներով և դրա ստեղծած արդյունքները համեմատվում են ակնկալվող արդյունքների հետ։ Կատարման ժամանակ ծրագիրը պարզապես շահագործվում է ըստ իր նշանակության։

\texttt{prog01} մոդուլն աշխատեցնելու համար պարզապես պետք է Bash-ի հրամանային տողից այն գործարկել ինչպես որևէ այլ ծրագիր.

\begin{verbatim}
$ ./prog01
Ողջո՜ւյն։
Այդ ե՛ս եմ՝ քո առաջին C ծրագիրը։
\end{verbatim}

Հիմա, եթե \texttt{echo} հրամանով արտածենք Bash-ի \verb|$?| փսոևդոփոփոխականը, որը պարունակում է վերջին աշխատած ծրագիր ավարտի կոդը, ապա կստանանք \texttt{0} արժեքը։ Այս \texttt{0}-ն հենց \texttt{main} ֆունկցիայից \texttt{return} հրամանով վերադարձրած արժեքն է։

\begin{verbatim}
$ echo $?
0
\end{verbatim}

Համոզվելու համար կարող ենք, օրինակ, \texttt{return 0;} հրամանը ծրագրում փոխարինել, \texttt{return 7;} հրամանով, ապա կատարելուց հետո նորից ստուգել \verb|$?|-ի արժեքը։

\emph{Շտկում} (debugging) --- եթե կոմպիլյացիայի, թեսթավորման կամ կատարման քայլերում ծրագրում հայտնաբերվել են բառային (լեքսիկական), շարահյուսական կամ տրամաբանական սխալներ,  ապա շտկումներ են կատարվում ծրագրի տեքստում և կոմպիլյացիայի, կատարման կամ թեսթավորման քայլերը նորից կրկնվում են անհրաժեշտ հաջորդականությամբ։

Այս պարզագույն օրինակում, իհարկե, դժվար է ինչ-որ մի տեխնիկական սխալ անել։ Բայց ենթադրենք, թե մոռացել ենք 6-րդ տողն ավարտող \verb|;| նիշը։ Կոմպիլյատորը կհայտնաբերի սխալը և կարտածի համապատասխան հաղորդագրություն.

\begin{verbatim}
prog01.c: In function ‘main’:
   prog01.c:7:4: error: expected ‘;’ before ‘puts’
   puts("Այդ ե՛ս եմ՝ քո առաջին C ծրագիրը։");
   ^~~~
\end{verbatim}

Այս հաղորդագրությունը՝ \texttt{prog01.c:7:4: error: expected ‘;’ before ‘puts’}, ասում է, որ \texttt{prog01.c} ֆայլի 7-րդ տողի 4-րդ դիրքի մոտ՝ \texttt{puts} բառից առաջ սպասվում է \verb|;| նիշը։
