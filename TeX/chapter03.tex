\chapter{Ֆունկցիաներ}

%\begin{quote}
%\emph{Ֆունկցիաների հայտարարումն ու սահմանումը, ֆունկցիայի արգումենտներն
%ու վերադարձրած արժեքը։}
%\end{quote}

Ինչպես և մաթեմատիկայում, որտեղից եկել է \emph{ֆունկցիա} տերմինը, Սի լեզվում
էլ ֆունկցիաները նախատեսված են տվյալների մի բազմությունը մեկ այլ բազմության
արտապատկերելու համար։ Օրինակ, նախորդ զրույցում հիշատակված \texttt{sqrt}
ֆունկցիան արգումենտում սպասում է \texttt{double} տիպի արժեք և վերադարձնում է
այդ արժեքի երկրորդ աստիճանի արմատը՝ նորից \texttt{double} տիպի արժեք։ Կարող
եմ ասել, որ \texttt{sqrt} ֆունկցիան \texttt{double} արժեքների բազմությունն
արտապատկերում է նույն \texttt{double} արժեքների բազմությանը։ Մաթեմատիկորեն
այդ փաստը սովորաբար գրառվում է հետևյալ կերպ․

\[
sqrt : double \mapsto double
\]

Իսկ C լեզվով այս նույն \emph{հայտարարությունը} գրառվում է այսպես․

\begin{Verbatim}
double sqrt(double);
\end{Verbatim}

Մեկ այլ օրինակ է նորից նախորդ զրույցում հիշատակված \texttt{atan2} ֆունկցիան։
Այն արգումենտում սպասում է երկու \texttt{double} թվեր՝ կետի կոորդինատները և
վերադարձնում է աբսցիսների առանցքի և կոորդինատների սկզբնակետով ու տրված կետով
անցնող ուղղի կազմած անկյունը՝ նորից \texttt{double} թիվ՝ \((−\pi, \pi]\)
միջակայքից։ Մաթեմատիկական գրառումը հետևյալն է․

\[
atan2 : double \times double \mapsto double
\]

C լեզվով գրառումն էլ այսպիսինն է․

\begin{Verbatim}
double atan2( double, double );
\end{Verbatim}

Եվ այսպես, Սի ծրագրավորման լեզվում ֆունկցիայի հայտարարությունն ունի երեք
բաղադրիչ. \emph{վերադարձվող արժեքի տիպ}, \emph{ֆունկցիայի անուն} և
\emph{պարամետրերի տիպերի ցուցակ}։ Վերադարձվող արժեքի տիպը և պարամետրերի տիպն
իրար հետ կոչվում է \emph{ֆունկցիայի տիպ}։

Երբեմն ֆունկցիայի տիպ են անվանում վրա վերադարձրած արժեքի տիպը։ Բնականաբար
դա սխալ է, որովհետև միայն վերադարձվող արժեքի տիպը չի կարող միարժեքորեն
բնորոշել ֆունկցիան։

Ինչպես փոփոխականների դեպքում, այնպես էլ ֆունկցիաներն է պետք օգտագործումից
առաջ հայտարարել։ Բայց Սի լեզվում հայտարարելուց բացի պետք է նաև \emph{սահմանել}
ֆունկցիաների վարքը՝ տալ այն գործողությունները, որ ֆունկցիան կատարում է
\emph{որոշման տիրույթն} \emph{արժեքների տիրույթին} արտապատկերելու համար։
Ֆունկցիայի վարքը սահմանող բլոկը կոչվում է \emph{ֆունկցիայի մարմին} և որոշվում
է \emph{վերնագրից} հետո գրված ու \verb|{|, \verb|}| փակագծերի մեջ առնված
հրամանների հաջորդականությամբ։ Օրինակ, նախորդ զրույցում դեկարտյան կոորդինատներից
բևեռային կոորդինատները ստանալու համար օգտագործեցի երկու բանաձև՝ կետի շառավիղը
և ազիմուտը հաշվող կանոնները։ Կարող եմ սահմանել, օրինակ, \texttt{radius}
ֆունկցիան հետևյալ կերպ․

\begin{Verbatim}
/* շառավղի հաշվումը դեկարտյան կոորդինատներով */
double radius( double x, double y )
{
  return sqrt( x * x + y * y );
}
\end{Verbatim}

Սի լեզվի \texttt{return} հրամանը ֆունկցիայից արժեք վերադարձնող գործողությունն
է։ Այն իր կիրառման կետում ավարտում է ֆունկցիայի կատարումը և ծրագրի ղեկավարումը
փոխանցում է տվյալ ֆունկցիայի կանչի կետին հաջորդող հրամանին։ Յուրաքանչյուր
ֆունկցիա պարտավոր է ունենալ գոնե մեկ \texttt{return} հրաման և այդ հրամանի
արգումենտն էլ հենց ֆունկցիայի արժեքն է։

\texttt{radius} ֆունկցիայի պես կարող եմ սահմանել նաև \texttt{azimuth} ֆունկցիան․

\begin{Verbatim}
/* ազիմուտի հաշվումը դեկարտյան կոորդինատներով */
double azimuth( double x, double y )
{
  return atan2( y, x );
}
\end{Verbatim}

Այս օրինակներից երևում է, որ, ի տարբերություն ֆունկցիայի հայտարարության,
ֆունկցիայի սահմանման ժամանակ վերնագրում պետք է գրել ոչ թե պարամետրերի տիպերի
ցուցակը, այլ պարամետրերի հայտարարությունների ցուցակը։ Սակայն, եթե ծրագրում
\texttt{x}, \texttt{y} և \texttt{z} փոփոխականները թույլատրելի է հայտարարել
մեկ հրամանով՝

\begin{Verbatim}
float x, y, z;
\end{Verbatim}

ապա ֆունկցիայի սահմանման ժամանակ այդպիսի բան գրել չի կարելի․

\begin{Verbatim}
? int f( int x, y, z )
? {
?   return x + y + z;
? }
\end{Verbatim}

Ամեն մի պարամետրի անունից առաջ պետք է գրել իր տիպը։ Այսպես․

\begin{Verbatim}
int f( int x, int y, int z )
{
  return x + y + z;
}
\end{Verbatim}

Կարծում եմ արդեն պարզ է, որ Սի լեզվի ֆունկցիաները հնարավորություն են տալիս
ամբողջությամբ մոդելավորել ֆունկցիայի մաթեմատիկական գաղափարը։ Բայց ծրագրավորման
գործում հաճախ հանդիպում են դեպքեր, երբ մեզ չի հետաքրքրում ֆունկցիայի
վերադարձրած արժեքը, կամ ֆունկցիան ընդհանրապես վերադարձվող արժեք չունի։ Այդ
դեպքերում Սի լեզուն առաջարկում է ֆունկցիայի վերադարձվող արժեքի տիպը նշել
\texttt{void} ծառայողական բառով։ Օրինակ, կարող եմ սահամանել մի ֆունկցիա, որն
\texttt{stdout} հոսքին է արտածում իմ անունը.

\begin{Verbatim}
void my_name()
{
  puts( "Ընկ. Ա. Բադալյան" );
}
\end{Verbatim}

Այս ֆունկցիան արգումենտներ չի ստանում և արժեք չի վերադարձնում. այն պարզապես
կատարում է նախապես որոշված ինչ-որ գործ։ Հաճախ \texttt{void} վերադարձրած
արժեքի տիպ ունեցող ֆունկցիային անվանում են \emph{պրոցեդուրա}։


\texttt{scanf} ֆունկցիայի մասին պատմելիս ասացի, որ այն, ըստ իր առաջին
արգումենտում տրված ֆորմատի, կարդում է արժեքներ և գրում է ֆորմատավորման
հրահանգներին համապատասխան երկրորդ և հաջորդ արգումենտներով տրված
\emph{հասցեներում}։ Հիմա ուզում եմ պատմել, թե ինչպես են օգտագործվում
փոփոխականների հասցեները։

Եթե ուզում եմ ծրագրում հայտարարել, որ պատրաստվում եմ \texttt{a0} փոփոխականին
վերագրել ամբողջ թվեր, իսկ \texttt{a1} փոփոխականին՝ նիշեր, ապա պետք է գրեմ.

\begin{Verbatim}
int a0 = 777;
char a1 = 'A';
\end{Verbatim}

Եթե ուզում եմ հայտարարել, որ \texttt{p0} փոփոխականին վերագրելու եմ ամբողջաթիվ
փոփոխականի հասցե, իսկ \texttt{p1} փոփոխականին՝ նիշային փոփոխականի հասցե,
ապա պետք է գրեմ․

\begin{Verbatim}
int* p0 = &a0;   /* p0 ցուցիչը արժեքավորել a0-ի հասցեով */
char* p1 = &a1;  /* p1 ցուցիչը արժեքավորել a1-ի հասցեով */
\end{Verbatim}

Փոփոխականի հայտարարման այս նոր գրելաձևը, երբ տիպի անունից հետո գրված է
\verb|*| նիշը, հենց \emph{ցուցիչ} փոփոխականի հայտարարման ձևն է (իսկ \verb|&|
գործողությունը փոփոխականի հասցեն վերցնելու գործողությունն է)։

Հիմա կարող եմ \texttt{a0} և \texttt{a1} փոփոխականներին արժեք վերագրել ոչ թե
ուղղակիորեն, այլ նրանց հասցեի միջոցով։ Օրինակ այսպես․

\begin{Verbatim}
*p0 = 888;  /* a0-ին վերագրել 888 */
*p1 = 'B';  /* a1-ին վերագրել 'B' */
\end{Verbatim}

Այս դեպքում արդեն \verb|*| գործողությունը կոչվում է \emph{ապահասցեավորման}
գործողություն (ի հակադրություն \verb|&| գործողության, որը \emph{հասցեավորման}
գործողությունն է)։

Հիմա, երբ արդեն գիտեմ, որ կարող եմ ֆունկցիային տալ փոփոխականի հասցեն և
ֆունկցիան էլ կարող է իր հաշվարկած արժեքները գրել այս հասցեում, կսահմանեմ
մի նոր ֆունկցիա, որը, ստանալով կետի դեկարտյան կոորդինատները, վերադարձնում
է նույն այդ կետի բևեռային կոորդինատները։ Բայց վերադարձնում է ոչ թե որպես
ֆունկցիայի արժեք, այլ հաշվարկած արժեքները գրում է տրված հասցեներում։

\begin{Verbatim}
void polar( double x, double y, double* rho, double* phi )
{
  *rho = sqrt( x * x + y * y );
  *phi = atan2( y, x );
}
\end{Verbatim}

\texttt{polar} ֆունկցիան ստանում է երկու իրական թիվ, որոնք ֆունկցիայի
արգումենտներն են, և իրական թվերի երկու ցուցիչներ, որոնք, ըստ էության,
ֆունկցիայի վերադարձվող արժեքներն են։ Այս նոր ֆունկցիան օգտագործվում է
ճիշտ այնպես, ինչպես օգտագործվում էր \texttt{scanf} ֆունկցիան՝ ստեղնաշարից
կոորդինատների կարդալու ժամանակ․

\begin{Verbatim}
double x = 0.0, y = 0.0;
scanf( "%lf,%lf", &x, &y );

double rho = 0.0, phi = 0.0;
polar( x, y, &rho, &phi );
\end{Verbatim}

Քանի որ \texttt{polar} ֆունկցիան արժեքները վերադարձնում է որպես ցուցիչ
տրված արգումենտների միջոցով, պետք է սահմանման մեջ նշել, որ այս ֆունկցիան
սովորական իմաստով վերադարձվող արժեք չունի և չի օգտագործելու \texttt{return}
հրամանը։ Ես դա արել եմ ֆունկցիայի տիպը նշելով որպես \texttt{void}։


Ծրագրի առանձին, տրամաբանորեն անկախ հատվածները ֆունկցիաների տեսքով
կազմակերպելով կարծես թե ստեղծում ենք խաղալիք կոնստրուկտորի մասնիկները,
որոնցից հետո հավաքելու ենք պետք եղած օբյեկտը՝ ծրագիրը։ Բացի այդ,
հնարավորություն ենք ստեղծում առանձին֊առանձին \emph{թեստավորել} այդ հատվածները։

\marginpar{Ֆունկցիայի հասցեի մասին}

Ծրագրավորման C լեզուն թույլ է տալիս սահմանել ֆունկցիաներ՝ առանց նշելու
դրանց պարամետրերի ճիշտ քանակը։ Այդպիսի ֆունկցիաների պարամետրերի ցուցակը
պետք է բաղկացած լինի գոնե մեկ հայտարարված պարամետրից և բազմակետերից։
Օրինակ, արդեն հիշատակված \texttt{scanf} և \texttt{printf} ֆունկցիաների
հայտարարությունը մոտավորապես հետևյալն է․

\begin{Verbatim}
int scanf( const char* format, ... );
int printf( const char* format, ... );
\end{Verbatim}

Ստանդարտ գրադարանի \texttt{stdarg.h} ֆայլում հայտարարված են բոլոր այն
անհրաժեշտ միջոցները, որոնց օգնությամբ սահմանվում են \emph{վարիադիկ}
ֆունկցիաները։

Ֆունկցիաների մասին առայժմ այսքանը։ Բայց սա դեռ ամբողջը չէ։
