\chapter{Փոփոխականներ}

\begin{quote}
\emph{Փոփոխականների հայտարաումը, փոփոխականի տիպը, փոփոխականին արժեքի
վերագրումը, փոփոխականի հասցե, ներմուծման ստանդարտ հոսքից տվյալների
կարդալը։}
\end{quote}

C լեզվով գրված ամեն մի ծրագիր, բացառությամբ պարզագույն դեպքերի,
պարունակում է փոփոխականներ։ \emph{Փոփոխականը} մի օբյեկտ է, որը ծրագրի
կատարման տարբեր պահերի կարող է պարունակել նախապես որոշված արժեքների
տիրույթի (domain) մի որևէ արժեք։ Յուրաքանչյուր փոփոխական, որ հանդիպում է
ծրագրում, պետք է նախապես \emph{սահմանված} լինի։ Փոփոխականի սահմանումը
բաղկացած է նրա \emph{տիպը} որոշող ծառայողական բառից և փոփոխականի
\emph{անունից}։ Օրինակ.

\begin{Verbatim}
double a;      /* a-ն կրկնակի ճշտությամբ իրական թիվ է */
float b, c;    /* b-ն և c-ն սովորական ճշտության իրական թվեր են */
int d0, d1;    /* d0-ն և d1-ը ամբողջ թվեր են */
char sym;      /* sym-ը նիշ է (character) */
long int e1a;  /* e1a-ն երկար ամբողջ թիվ է */
\end{Verbatim}

Այստեղ \code{double}, \code{float}, \code{int}, \code{char} և \code{long}
բառերը \emph{ծառայողական բառեր} են և \emph{ներդրված} տիպերի անուններ։
Իսկ \ident{a}, \ident{b}, \ident{c}, \ident{d0}, \ident{d1},
\ident{sym} և \ident{e1a} բառերը իդենտիֆիկատորներ են։ Սի լեզվի
\emph{իդենտիֆիկատորը} տառով կամ ընդգծման նիշով՝ «\verb|_|», սկսվող
տառերի ու թվանշանների հաջորդականություն է։ Պետք է հիշել, որ Սի լեզվում
մեծատառերն ու փոքրատառերը տարբերվում են, այսինքն՝ \ident{abc0} և
\ident{aBc0} բառերը տարբեր իդենտիֆիկատորներ են։

Փոփոխականի տիպով որոշվում է հիշողությունում նրա զբաղեցրած բայթերի
քանակը և նրա հետ կատարվող թույլատրելի գործողությունները։ Օրինակ, իմ
համակարգում \code{int} տիպ ունեցող փոփոխականը զբաղեցնում է 4 բայթ,
\code{double} տիպ ունեցող փոփոխականը՝ 8 բայթ, իսկ \texttt{char} տիպի
փոփոխականը՝ 1 բայթ։ Ծրագրի կատարման ժամանակ փոփոխականի զբողեցրած
հիշողության չափը կարելի է ստանալ \code{sizeof} գործողության օգնությամբ։
Օրինակ, եթե \ident{a0}-ն \code{double} տիպի փոփոխական է, ապա
\texttt{sizeof(a0)} արտհայտության արժեքը 8 է։ \texttt{sizeof}
գործողության արգումենտը կարող է լինել ոչ միայն փոփոխականի անուն, այլ
նաև Սի լեզվի տիպի անուն։ Օրինակ, \texttt{sizeof(unsigned int)}
արտահայտության արժեքը առանց նշանի ամբողջ թվերը որոշող տիպի չափն է։

Փոփոխականին կարելի է արժեք վերագրել հենց անմիջապես հայտարարության
ժամանակ։ Ընդհանրապես, ծրագրավորման «լավ ոճ» է համարվում, երբ փոփոխականին
արժեք է վերագրվում հայտարարության հետ միասին։ Օրինակ, հետևյալ հատվածում
հայտարարված են.

\begin{Verbatim}
int count = 0;      /* count ամբողջաթիվ փոփոխականը՝ 0 արժեքով */
double pi = 3.1415; /* pi իրական փոփոխականը՝ 3.1415 արժեքով */
char c = 'A';       /* c նիշային փոփոխականը՝ «A» արժեքով */
\end{Verbatim}

Փոփոխականին նոր արժեք է տրվում \texttt{=} \emph{վերագրման}
գործողությամբ։ Օրինակ,

\begin{Verbatim}
double a0, a1, b0;  /* a0-ն, a1-ը և b0-ն իրական թվեր են */
a0 = 2.36;          /* a0-ին վերագրել 2.36 */
a1 = 4.1;           /* a1-ին վերագրել 4.1 */
b0 = a0 + a1;       /* b0-ին վերագրել a0-ի և a1-ի գումարը */
\end{Verbatim}

Ծրագրի կատարման ժամանակ ամեն մի հայտարարված փոփոխականի հատկացվում է
հիշողության մի որոշակի տիրույթ։ Այդ տիրույթի առաջին բայթի համարը
փոփոխականի \emph{հասցեն} է, որը կարող ենք ստանալ \texttt{\&} միտեղանի
(unary) գործողությամբ։ Օրինակ, \texttt{\&pi} արտհայտության արժեքը
\texttt{pi} փոփոխականի հասցեն է։

Ես ուզում եմ ցույց տալ ու մեկնաբանել մի ծրագիր, որն օգտագործողից
պահանջում է ներմուծել հարթության մի որևէ կետի դեկարտյան կոորդինատները և
արտածում է նույն այդ կետի բևեռային կոորդինատները։

Պարզ է, որ կետի դեկարտյան կոորդինատները ներկայացնելու համար պետք է
հայտարարել \texttt{x} և \texttt{y} իրական փոփոխականները, ապա դրանց
արժեքները կարդալ ստեղնաշարից։

\begin{Verbatim}
double x = 0.0, y = 0.0;
scanf( "%lf", &x );  /* կարդալ իրական թիվ և վերագրել x-ին */
scanf( "%lf", &y );  /* նույնը՝ y-ի համար */
\end{Verbatim}

C լեզվի ստանդարտ գրադարանի \texttt{scanf} (scan formated ― ֆորմատավորված
ընթերցում) ֆունկցիան ներմուծման ստանդարտ հոսքից (stdin) կարդում է նիշերի
հաջորդականություն և այն ձևափոխում է ըստ տրված ֆորմատի։ \texttt{scanf}
ֆունկցիայի առաջին արգումենտը ֆորմատավորման տողն է, որ կարող է պարունակել
\texttt{\%} նիշով սկսվող ֆորմատավորման հրահանգներ։ \texttt{\%} նիշին
հաջորդող նիշերով որոշվում է, թե ինչպես պետք է մեկնաբանվեն կարդացած
տվյալները։ Օրինակ, եթե գրված է \texttt{\%d}, ապա սա նշանակում է, որ
հոսքից կարդացած նիշերը պետք է դիտարկել որպես տասական (decimal) թիվ։ Եթե
գրված է \texttt{\%f}, ապա՝ սովորական ճշտության իրական (float) թիվ։
Ֆորմատավորման հրահանգներին համապատասխան ձևափոխված տվյալները գրվում են
\texttt{scanf} ֆունկցիայի երկրորդ և հաջորդ արգումենտներով տրված
հասցեներում։ Օրինակ.

\begin{Verbatim}
scanf( "%lf", &x );
\end{Verbatim}

արտահայտության մեջ տրված \texttt{"\%lf"} ֆորմատը նշում է, որ պետք է
կարդալ երկար իրական թիվ (l - long, f - float) և կարդացած արժեքը գրել
\texttt{x} փոփոխականի զբաղեցրած հասցեում։ \texttt{scanf} ֆունկցիային
փոխանցվում է ոչ թե փոփոխականը, այլ նրա հասցեն՝ այն տեղը, որտեղ պետք է
գրել կարդացած և ֆորմատավորած տվյալները։

\texttt{scanf} և \texttt{printf} ֆունկցիաների ֆորմատավորման հրահանգների
մասին ես դեռ պատմելու շատ առիթներ կունենամ։ Առայժմ բավական է իմանալ, որ
\texttt{"\%lf"} ֆորմատը կարդում է \texttt{double} արժեք։

\texttt{x} և \texttt{y} փոփոխականների արժեքները կարդացող \texttt{scanf}
ֆունկցիայի երկու կանչերը կարելի է միավորել մեկի մեջ՝ \texttt{"\%lf"}
ֆորմատը փոխարինելով \texttt{"\%lf,\%lf"} ֆորմատով։ Սա նշանակում է, որ
\texttt{scanf} ֆունկցիան ստեղնաշարից կարդալու է իրարից ստորակետով
բաժանված երկու \texttt{double} արժեք։

\begin{Verbatim}
double x = 0.0, y = 0.0;
scanf( "%lf,%lf", &x, &y );  /* կարդալ երկու իրական թվեր և վերագրել x-ին ու y-ին */
\end{Verbatim}

Դե քանի որ \texttt{scanf} ֆունկցիայի ֆորմատավորման տողը պարունակում է
երկու ֆորմատավորման հրահանգ, ապա պետք է տալ կարդացած արժեքները գրելու
երկու տեղ՝ \texttt{\&x} և \texttt{\&y}։

Եթե պետք լինի օգտագործողին ստիպել, որ նա կետի կոորդինատները ներմուծի
\texttt{(} և \texttt{)} փակագծերի մեջ վերցրած, ապա կարելի է
ֆորմատավորման տողը գրել \texttt{"(\%lf,\%lf)"} տեսքով։ Բառացիորեն սա
կարելի է կարդալ հետևյալ կերպ. «\emph{կարդալ \texttt{(} նիշը, կարդալ
\texttt{double} թիվ, կարդալ \texttt{,} նիշը, կարդալ \texttt{double} թիվ,
կարդալ \texttt{)} նիշը}»։

Կետի \texttt{x} \emph{աբսցիսի} և \texttt{y} \emph{օրդինատի} արժեքները
կարդալուց հետո պետք է հաշվել նրա բևեռային կոորդինատները՝ \texttt{ρ}
\emph{շառավիղը} և \texttt{φ} \emph{ազիմուտը}։ Կոորդինատների բևեռային
համակարգում \texttt{ρ}-ն որոշվում է որպես կետի հեռավորությունն բևեռից,
իսկ \texttt{φ}-ն՝ որպես շառավղի և բևեռային առանցքի կազմած անկյուն։
Բևեռային շառավիղը որոշվում է Պյութագորասի թեորեմով՝ քանի որ այն իրենից
ներկայացնում է ուղղանկյուն եռանկյան ներքնաձիգ։ Բևեռային անկյունը
որոշելու համար էլ օգտվում ենք նույն ուղղանկյուն եռանկյունից և այն
փաստից, որ որոնելի անկյան տանգենսը հավասար է նրա դիմացի էջի երկարության
հարաբերությանը կից էջի երկարությանը՝ \texttt{y/x}, դե իսկ անկյան
մեծությունն էլ հավասար կլինի այդ վերջին հարաբերության արկտանգենսին։

![կոորդինատներ](nacl-fig-1.png)

Ասվածը C լեզվով կարող եմ գրել հետևյալ արտահայտություններով․

\begin{verbatim}
double rho = sqrt( x * x + y * y );
double phi = atan2( y, x );
\end{verbatim}

\texttt{sqrt} ֆունկցիան վերադարձնում է արգումենտի երկրորդ աստիճանի
արմատը, իսկ \texttt{atan2} ֆունկցիան վերադարձնում է \texttt{0} սկզբնակետ
և \texttt{(x,y)} վերջնակետ ունեցող վեկտորի և աբսցիցների առանցքի կազմած
անկյունը ռադիաններով։ Այս երկու ֆունկցիաներն էլ սահմանված են C լեզվի
ստանդարտ գրադարանի \texttt{math.h} ֆայլում։

\texttt{rho} և \texttt{phi} արժեքների հաշվարկից հետո պարզապես պետք է
արտածել դրանք․

\begin{verbatim}
puts( "Բևեռային կոորդնատներն են․ " );
printf( "ρ = %lf, φ = %lf\n", rho, phi );
\end{verbatim}

\texttt{printf} ֆունկցիայում նույնպես օգտագործվել են \texttt{"\%lf"}
ֆորմատավորման հրահանգները։ Քանի որ \texttt{printf} ֆունկցիան իր
արգումենտները չի փոխում, այստեղ նրան փոխանցում ենք \texttt{x} և
\texttt{y} փոփոխականների արժեքները, այլ ոչ թե հասցեները։

Վերջ։ Մնում է այս ամենը հավաքել \texttt{main} ֆունկցիայի մեջ,
կոմպիլյացնել, գործարկել ու տեսնել արդյունքները։ Ես ամբողջ ծրագիրը գրել
եմ \texttt{prog02.c} ֆայլի մեջ։

\begin{verbatim}
#include <stdio.h>
#include <math.h>

int main()
{
  double x = 0.0, y = 0.0;
  puts( "Ներմուծիր դեկարտյան կոորդինատները x,y․ " );
  scanf( "%lf,%lf", &x, &y );

  double rho = sqrt( x * x + y * y );
  double phi = atan2( y, x );

  puts( "Բևեռային կոորդնատներն են․ " );
  printf( "ρ = %lf, φ = %lf\n", rho, phi );

  return 0;
}
\end{verbatim}

\texttt{\#include} դիրեկտիվով կցվել են \texttt{stdio.h} և
\texttt{math.h} ֆայլերը։ Առաջինից օգտագործվում են \texttt{puts},
\texttt{scanf} և \texttt{printf} ֆունկցիաները, իսկ երկրորդից՝
\texttt{sqrt} և \texttt{atan2} ֆունկցիաները։

Երբ ես փորձում եմ \texttt{prog02.c} ֆայլը կոմպիլյացնել այնպես, ինչպես դա
արեցի առաջին զրույցում նկարագրված \texttt{prog01.c} ֆայլի հետ.

\begin{verbatim}
$ clang prog02.c -o prog2
\end{verbatim}

ապա ստանում եմ մի հաղորդագրություն, որն ասում է, թե linker ծրագիրը՝
\emph{կապերի խմբագրիչը}, չի գտել \texttt{sqrt} և \texttt{atan2}
ֆունկցիաները։

\begin{verbatim}
/tmp/prog02-80b543.o: In function `main':
prog02.c:(.text+0x6a): undefined reference to `sqrt'
prog02.c:(.text+0x91): undefined reference to `atan2'
clang: error: linker command failed with exit code 1 (use -v to see invocation)
\end{verbatim}

Բանն այն է, որ \texttt{math.h} ֆայլը պարունակում է մաթեմատիկական
գրադարանի հայտարարությունները, բայց ոչ սահմանումները։ Սահմանումները,
այսինքն մաթեմատիկական գրադարանի կոմպիլյացված օբյեկտային կոդը, գտնվում է
\texttt{libm.a} (ստատիկ) և \texttt{libm.so} (դինամիկ) օբյեկտային
ֆայլերում։ ՈՒրեմն, երբ ծրագրի ֆայլում \texttt{\#include} դիրեկտիվով
կցում ենք \texttt{math.h} ֆայլը, դա անում ենք, պարզպես, որ կոմպլյատորն
իմանա օգտագործվող ֆունկցիաների հայտարարությունները։ Իսկ կապերի խմբագրման
(link) ժամանակ, երբ պետք է ստացվի կատարվող ֆայլ, կոմպիլյատորի
\texttt{-l} պարամետրով պիտի տալ \texttt{m} գրադարանը (գրադարանների
անունները սկսվում են lib նախածանցով, բայց \texttt{-l} պարամետրով
գրադարանը նշելիս lib-ը չի գրվում)։

\texttt{prog02.c} ֆայլի կոմպիլյացիայի՝ վերը բերված հրամանն իրականում
կատարվում է չորս քայլով՝ \emph{նախամշակում} (preprocessing),
\emph{կոմպիլյացիա} (compilation), \emph{ասեմբլացում} (assembly) և
\emph{կապակցում} (linking)։ Նախամշակման փուլում մշակվում են \texttt{\#}
նիշով սկսվող հրահանգները. \texttt{\#include} հրահանգով կցվում են ֆայլեր,
\texttt{\#define} հրահանգով սահմանվում են մակրոսներ և այլն (նախամշակման
քայլի մասին մանրամասն կխոսեմ քիչ ավելի ուշ)։ Կոմպիլյացիայի փուլում C
լեզվով գրված ծրագիրը թարգմանվում է ասեմբլերի լեզվով գրված ծրագրի։
Ասեմբլացման փուլում ասեմբլերի լեզվով ծրագիրը թարգմանվում է կոնկրետ
ապարատային պլատորմի վրա աշխատող կոնկրետ օպերացիոն համակարգի օբյեկտային
կոդի։ Կապակցման փուլում իրար են կցվում առանձին-առանձին կոմպիլյացված
օբյեկտային մոդուլները, ստեղծվում է կատարվող մոդուլ։ Եթե ուզում ես
տեսնել, թե այդ միջանկյալ քայլերում ինչ ֆայլեր են գեներացվում, ապա կարող
ես կոմպիլյացիայի հրամանին տալ \verb|--save-temps| պարամետրը.

\begin{verbatim}
$ clang --save-temps -o prog02 prog02.c -lm
\end{verbatim}

Այս հրամանի կատարումից հետո ստեղծվում են \texttt{prog02.i},
\texttt{prog02.s}, \texttt{prog02.o}, \texttt{prog02} ֆայլերը։ Դրանք
համապատասխանաբար նախամշակման, կոմպիլյացիայի և ասեմբլացման փուլերում
ստեղծված ֆայլերն են։ Կապակցման արդյունքում ստացված ֆայլը ստանում է
կոմպիլյատորի ՝-օ՝ պարամետրով տրված անունը։

Կոմպիլյացիայի քայլերը ես էլ կարող եմ առանձնացնել։

\begin{enumerate}
\item \texttt{clang -E -o prog02.i prog02.c} --- Նախամշակել, բայց
  չկոմպիլյացնել։ Ստեղծվում է \texttt{prog02.i} ֆայլը։
\item \texttt{clang -S -o prog02.s prog02.i} --- Կոմպիլյացնել նախամշակված
  ֆայլը, բայց չասեմբլացնել։ Ստեղծվում է \texttt{prog02.s} ֆայլը։
\item \texttt{clang-3.5 -c -o prog02.o prog02.s} --- Ասեմբլերային ֆայլը
  թարգմանել օբյեկտային ֆայլի։ Ստեղծվում է \texttt{prog02.o} ֆայլը։
\item \texttt{clang -o prog02 prog02.o -lm} --- Օբյեկտային ֆայլը կապակցել
  գրադարանների հետ և ստեղծել \texttt{prog02} կատարվող մոդուլը։
\end{enumerate}

Հիմա արդեն ամեն ինչ կարգին է․ ֆայլը թարգմանվել է և կառուցվել է
\texttt{prog02} կատարվող ֆայլը։ Գործարկեմ այն ու տեսնեմ, թե ինչ է
ստացվում․

\begin{verbatim}
$ ./prog02
Ներածիր դեկարտյան կոորդինատները x,y․
3,2
Բևեռային կոորդնատներն են․
ρ = 3.605551, φ = 0.588003
\end{verbatim}

Հենց որ ծրագիրն առաջարկում է ներածել \texttt{x} և \texttt{y} դեկարտյան
կոորդինատները, ես ներածում եմ \texttt{3,2} թվերը։ Դրան ի պատասխան
ծրագիրն արտածել է \texttt{ρ\ =\ 3.605551} և \texttt{φ\ =\ 0.588003}
արժեքները։

Այս զրույցի համար էլ այսքանը։ Հաջորդ զրույցում կպատմեմ ֆունկցիաների
սահմանման, դրանց արգումենտների ու վերադարձրած արժեքի մասին։
