\chapter{Ճյուղավորման կառուցվածք}

Նախորդ զրույցներում իմ բերած օրինակները շատ պարզ էին․ ծրագիրը սկսվում էր
\texttt{main} ֆունկցիայից, կանչվում էր այս կամ այն ֆունկցիան, կատարվում էին
հաջորդական գործողություններ ու ծրագրի կատարումն ավարտվում էր։ Իսկ ի՞նչ անել,
երբ պետք է ծրագրի տրամաբանությունը ղեկավարել ներմուծված կամ ձևավորված
տվյալներից կախված։ Օրինակ, ինչպե՞ս սահմանեմ թվի նշանը որոշող \texttt{sign}
ֆունկցիան։ Այն պետք է արգումենտում ստացած դրականների թվի համար վերադարձնի՝
\texttt{1}, բացասականի համար՝ \texttt{-1}, իսկ զրոյի համար՝ \texttt{0}։
Պարզ է, որ ֆունկցիայի այդպիսի վարքը մոդելավորելու համար հարկավոր է
որևէ \emph{ճյուղավորման} կառուցվածք։

Սի լեզվում ճյուղավորումները կազմակերպվում են \texttt{if} հրամանով.

\[
\mathbf{if}( \langle condition\rangle )
\langle then-block\rangle
\mathbf{else}
\langle else-block\rangle
\]

Եթե \emph{ճշմարիտ} է \(\langle condition\rangle\) պայմանը, ապա կատարվում
են \(\langle then-block\rangle\) հրամանները, հակառակ դեպքում կատարվում են
\(\langle else-block\rangle\) հրամանները։ Եթե պայմանի \emph{կեղծ} լինելու
դեպքում ոչինչ անել պետք չէ, ապա \emph{else} ծառայողական բառը և նրան հաջորդող
\(\langle else-block\rangle\) հրամանները կարելի է չգրել։ Օրինակ, այսպես.

\begin{verbatim}
if( argc == 1 )
  usage();
\end{verbatim}

\texttt{usage} ֆունկցիան կանչվում է միայն այն դեպքում, երբ \texttt{argc}
փոփոխականը հավասար է մեկի։

Արդեն տեղին է հիշատակել C լեզվի համեմատման գործողությունների մասին։ Դրանք
վեցն են և նախատեսված են թվերի ու նիշերի համեմատման համար, իսկ \verb|==| և
\verb|!=| գործողությունները օգտագործվում են նաև ցուցիչների հավասարությունն
ու անհավասարությունը ստուգելու համար։

\begin{center}
\begin{tabular}{c|c}
Գործողություն & Նշանակություն \\
\hline
== & հավասար է \\
!= & հավասար չէ \\
>  & մեծ է \\
>= & մեծ է կամ հավասար \\
<  & փոքր է \\
<= & փոքր է կամ հավասար \\
\end{tabular}
\end{center}

Հիմա վերը հիշատակված \texttt{sign} ֆունկցիայի մասին։ Այն կարող է ունենալ
հետևյալ տեսքը.

\begin{verbatim}
int sign( double num )
{
  int res = 0; /* զրոյի դեպքը */
  if( num < 0 ) /* եթե բացասական է */
    res = -1;
  else if( num > 0 ) /* այլապես եթե դրական է */
    res = 1;
  return res;
}
\end{verbatim}

Բայց, քանի որ \texttt{return} հրամանն իր կիրառման կետում ավարտում է ֆունկցայի
աշխատանքը, \texttt{sign} ֆունկցիան կարելի է գրել ավելի պարզ ձևով։

\begin{verbatim}
int sign( double num )
{
  if( num < 0 ) return -1; /* բացասական */
  if( num > 0 ) return 1;  /* դրական */
  return 0; /* զրո */
}
\end{verbatim}

Ճյուղավորման հրամանը հնարավորություն է տալիս ծրագրում կազմակերպել նաև
կրկնություններ։ Օրինակ, տրված \texttt{x} թվի \texttt{y} աստիճանը (երկուսն
էլ ամբողջ թվեր են) հաշվող ֆունկցիան կարող եմ սահմանել հետևյալ կերպ.

\begin{verbatim}
int power( int x, int y )
{
  if( y == 0 )  /* թվի զրո աստիճանը */
    return 1;   /* 1 է */
  return x * power( x, y - 1 ); /* x^y = x * x^(y - 1) */
}
\end{verbatim}

Այս ֆունկցիայում կրկնությունը մոդելավորված է \emph{ռեկուրսիայի} օգնությամբ.
\texttt{x} թվի հերթական \texttt{y} աստիճանը հաշվելու համար \texttt{x}-ը
բազմապատկվում է իր \texttt{y-1} աստիճանի արժեքի հետ։ Եթե որպես աստիճան տրված
է \texttt{0}, ապա վերադարձնում է \texttt{1}։

Մեկ այլ օրինակ՝ առանց ռեկուրսիայի օգտագործման։ \texttt{powers\_of\_two}
ֆունկցիան արգումենտում ստանում է \texttt{N} ամբողջ թիվը և ստանդարտ արտածման
հոսքին է արտածում \texttt{2}-ի \([0..N]\) աստիճանների աղյուսակը.

\begin{verbatim}
void powers_of_two( int nm )
{
  int pw = 0;
cycle:
  printf( "2^%d = %d\n", pw, 1 << pw );
  pw = pw + 1;
  if( pw <= nm ) goto cycle;
}
\end{verbatim}

Այստեղ ցիկլի կազմակերպման համար ես օգտագործել եմ բազմաչարչար \texttt{goto}
հրամանը և մի \emph{նշիչ}, \emph{պիտակ} (label)։ Սի լեզվի նշիչները
իդենտիֆիկատորներ են, որոնցից հետո դրվում է \verb|:|։ Դրանք կարող են գրվել
ցանկացած հրամանից առաջ և օգտագործում են այդ հրամանին ուղղակի անցում
կատարելու համար։ \texttt{powers\_of\_two} ֆունկցիայի չորրորդ տողում գրված
է \texttt{cycle} նշիչը, որին յոթերորդ տողում գրված \texttt{goto} հրամանով
անցում է կատարվում այն դեպքում, երբ \texttt{pw}-ի արժեքը դեռևս փոքր է
\texttt{nm}-ի արժեքից։

Երկուսի հերթական \texttt{pw} աստիճանը հաշվարկվում է \texttt{1 << pw}
արտահայտությամբ (\texttt{printf} ֆունկցիայի երրորդ արգումենտում)։ Այս
\verb|<<| գործողությունը իր ձախ արգումենտի բիթերը դեպի ձախ է տեղաշարժում
աջ արգումենում տրված քանակով՝ ազատված դիրքերը լրացնելով զրոներով։

\medskip
Բացի \texttt{if-else} ճյուղավորման հրամանից, Սի լեզուն ունի նաև
\texttt{switch} \emph{ընտրության} հրամանը, որը թույլ է տալիս ընտրություն
կատարել հաստատուն մեծության արժեքներ մեջ և ամեն մի արժեքին համապատասխանեցնել
հրամանների առանձին հաջորդականություն։ Նրա ընդհանուր տեսքն այսպիսինն է.

\begin{verbatim}
switch( ⟨expression⟩ ) {
  case ⟨value_1⟩:
    ⟨block_1⟩
  case ⟨value_2⟩:
    ⟨block_2⟩
  ...
  default:
    ⟨block_{def}⟩
}
\end{verbatim}

\texttt{switch} հրամանի արգումենտի \(\langle expression\rangle\)
արտահայտությունը պետք է լինի ամբողջաթիվ կամ նիշային, իսկ \texttt{case}
հրամանի արգումենտները՝ նույն տիպի հաստատուններ։ Եթե
\(\langle expression\rangle\)-ի արժեքը \(\langle value_1\rangle\) է,
ապա կատարվում են \(\langle block_1\rangle\) խմբի հրամանները, եթե
\(\langle value_2\rangle\) է, ապա՝ \(\langle block_2\rangle\) հրամանները
և այդպես շարունակ։ Եթե \(\langle expression\rangle\)-ի արժեքը ոչ մի
\texttt{case} տարբերակի չի համընկնում, ապա կատարվում է \texttt{default}
ծառայողական բառից հետո գրված \(\langle block_{def}\rangle\) հրամանները։

Օրինակ, սահմանեմ \texttt{day\_of\_week} (շաբաթվա օր) ֆունկցիան, որն
արգումենտում ստանում է ամբողջ թիվ և արտածում է համապատասխան շաբաթվա
օրվա անունը։

\begin{verbatim}
void day_of_week( int day )
{
  switch( day ) {
    case 1:
      puts( "երկուշաբթի" );
      break;
    case 2:
      puts( "երեքշաբթի" );
      break;
    case 3:
      puts( "չորեքշաբթի" );
      break;
    case 4:
      puts( "հինգշաբթի" );
      break;
    case 5:
      puts( "ուրբաթ" );
      break;
    case 6:
      puts( "շաբաթ" );
      break;
    case 7:
      puts( "կիրակի" );
      break;
    default:
      puts( "այդպիսի համարով օր չկա" );
  }
}
\end{verbatim}

Պետք է ուշադրություն դարձնել, որ բոլոր \texttt{case} բլոկներն ավարտվում
են \texttt{break} հրամանով։ Բանն այն է, որ \texttt{switch} հրամանի մարմինը
հրամանների մի ընդհանուր հաջորդականություն է, իսկ \texttt{case} և
\texttt{default} հրամաններն այդ հաջորդականության մեջ ձևավորում են նշիչներ։
Երբ սկսվում է կատարվել բլոկներից որևէ մեկը, ապա կատարվում են \texttt{switch}
հրամանի մարմնի հաջորդ բոլոր հրամանները։ \texttt{break} հրամանը հնարավորություն
է տալիս կատարումն ընդհատել հարկավոր տեղում։

Օրինակ, սահմանեմ \texttt{working\_day} (աշխատանքային օր) ֆունկցիան, որը
\([1..5]\) օրերի համար արտածում է «աշխատանքային օր է» արտահայտությունը, իսկ
\texttt{6} և \texttt{7} օրերի համար՝ «հանգստյան օր է» արտահայտությունը։

\begin{verbatim}
void working_day( int day )
{
  switch( day ) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      puts( "աշխատանքային օր է" );
      break;
    case 6:
    case 7:
      puts( "հանգստյան օր է" );
      break;
    default:
      puts( "այդպիսի համարով օր չկա" );
  }
}
\end{verbatim}

Հետաքրքրության համար կարելի է հեռացնել \texttt{break} հրամանները և տեսնել,
թե ինչ կկատարվի։


\texttt{day\_of\_week} ֆունկցիան սահմանեմ նաև \texttt{if-else} հրամանի օգնությամբ.

\begin{verbatim}
void day_of_week( int day )
{
  if( day == 1 )
    puts( "երկուշաբթի" );
  else if( day == 2 )
    puts( "երեքշաբթի" );
  else if( day == 3 )
    puts( "չորեքշաբթի" );
  else if( day == 4 )
    puts( "հինգշաբթի" );
  else if( day == 5 )
    puts( "ուրբաթ" );
  else if( day == 6 )
    puts( "շաբաթ" );
  else if( day == 7 )
    puts( "կիրակի" );
  else
    puts( "այդպիսի համարով օր չկա" );
}
\end{verbatim}

Հերթով դիտարկվում են \texttt{day} արգումենտի արժեքները և ամեն մեկի համար
արտածվում է համապատասխան բառը։ Ամենավերջին \texttt{else} ճյուղը կատարվում
է այն դեպքում, երբ \texttt{day} փոփոխականի արժեքը \([1..7]\) միջակայքից չէ։
