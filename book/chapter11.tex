\chapter{Դինամիկ գրադարանի կառուցումը}

Այս զրույցում ես պատմում եմ, թե ինչպես Սի լեզվով պատրաստել
գրադարան և այն օգտագործել ծրագրի մեջ։ Ինչպես նաև պատրաստել
այդ գրադարանի՝ \emph{դինամիկ} և \emph{ստատիկ} կապակցվող
մոդուլները։ Եվ քանի որ նպատակս գրադարանի ստեղծման տեխնիկայի
ցուցադրումն է, շատ բարդ բաների հետևից չեմ ընկնի և որպես
օրինակ կներկայացնեմ միայն մեկ ֆունկցիա պարունակող գրադարան։

Ենթադրենք ուզում եմ ստեղծել գրադարան, որը նախատեսված է տրված
միջակայքում տրված ֆունկցիայի թվային ինտեգրալը հաշվելու համար։
Օգտագործման հեշտության համար ուզում եմ, որ այդ գրադարանի
ինտերֆեյսը լինի հնարավորինս պարզ, այն է՝ պարունակի միակ
\ident{integrate} ֆունկցիան։ Այդ ֆունկցիան ստանում է ինտեգրվող
ֆունկցիայի ցուցիչն ու ինտեգրման միջակայքը։ Օրինակ, եթե \(x^2\)
ֆունկցիան սահմանված է հետևյալ կերպ.

\begin{Verbatim}
double sqr(double x)
{
    return x * x;
}
\end{Verbatim}

ապա \([-1;1]\) միջակայքում դրա թվային ինտեգրալը կարելի է հաշվել
հետևյալ հրամանով.

\begin{Verbatim}
double r0 = integral(&sqr, -1, 1);
\end{Verbatim}

Հիմա ցույց տամ, թե ինչպես է իրականացված \ident{integral}
ֆունկցիան, ինչպես կարելի է այդ իրականացումը վերածել
\emph{գրադարանի} և օգտագործել այլ ծրագրերում։

Նախ պետք է պատրաստել գրադարանի իրականացումը։ Դրա համար ստեղծում
եմ \code{ni.c} (numeric integral) ֆայլը, որում սահմանված են
\ident{epsilon} հաստատունը և Սիմպսոնի բանաձևը՝ \ident{simpson}
ֆունկցիան։

\begin{Verbatim}
static const double epsilon = 1e-5;

static double simpson( double(*f)(double), double a, double b )
{
  return ((b - a) / 6) * (f(a) + 4 * f((a + b) / 2) + f(b));
}
\end{Verbatim}

Նույն \texttt{ni.c} ֆայլում է սահմանված նաև \ident{integral}
ռեկուրսիվ ֆունկցիան, որը «բաժանիր և տիրիր» մոտեցմամբ հաշվում
է տրված ֆունկցիայի մոտավոր ինտեգրալը։

\begin{Verbatim}
double integral( double(*f)(double), double a, double b )
{
  if( b - a < epsilon )
    return simpson( f, a, b );
  double m = (a + b) / 2.0;
  return integral( f, a, m ) + integral( f, m, b );
}
\end{Verbatim}

Եթե ինտեգրման միջակայքի երկարությունը փոքր է նախապես սահմանված
\ident{epsilon} թվից, ապա այդ հատվածի վրա կիրառվում է Սիմպսոնի
բանաձևը։ Հակառակ դեպքում ինտեգրման միջակայքը տրոհվում է երկու
հավասար մասերի, մասերից ամեն մեկի վրա նորից կիրառվում է
\ident{integral} ֆունկցիան, իսկ ինտեգրման արժեք է համարվում
միջակայքի երկու կեսերի վրա ստացված արժեքների գումարը։

Որպեսզի հնարավոր լինի \ident{integrate} ֆունկցիան օգտագործել
այլ ծրագրում, Սի լեզվի կոմպիլյատորին պետք է հայտարարության
միջոցով տեղեկացնել դրա գոյության մասին։ Գրադարաններ
կազմակերպելիս «արտաքին աշխարհին» տրամադրվող անունների
(ֆունկցիաների, ստրուկտուրաների և այլն) հայտարարությունները
գրվում են \emph{վերնագրային} (header) ֆայլում։ Իսկ այն տեղում,
որտեղ պետք է օգտագործվի գրադարանը, \Verb|#include| հրահանգով
կցվում է վերնագրային ֆայլը։ Թվային ինտեգրալը հաշվող գրադարարանի
համար ստեղծեմ \texttt{ni.h} ֆայլը՝ հետևյալ պարունակությամբ․

\begin{Verbatim}
#ifndef NUMERIC_INTEGRAL
#define NUMERIC_INTEGRAL

extern double integral(double(*)(double), double, double);

#endif
\end{Verbatim}

Ֆունկցիայի հայտարարությունից առաջ գրված \ident{extern}
ծառայողական բառն ուզում է ասել, թե \ident{integral} ֆունկցիան
սահմանված է մի որևէ այլ տեղ (գուցե հենց նույն ֆայլում)։

Արդեն պատրաստ է «Numeric integral» գրադարանը․ դրա իրականացումը
\texttt{ni.c} ֆայլում է, իսկ \emph{ինտերֆեյսը}՝ \texttt{ni.h}
ֆայլում։ Հիմա ցույց տամ, թե ինչպես եմ այս գրադարանն օգտագործելու։
Ենթադրենք ուզում եմ \([-1;1]\) միջակայքի վրա հաշվել \(x^2\) և
\(x^3\) ֆունկցիաների մոտավոր ինտեգրալը։ Ստեղծեմ \texttt{prog11.c}
ֆայլը հետևյալ պարունակությամբ։

\begin{Verbatim}
#include <stdio.h>
#include "ni.h"

double sqr(double x) { return x * x; }
double cub(double x) { return x * x * x; }

int main()
{
  double r0 = integral( &sqr, -1, 1 );
  printf( "> %lf\n", r0 );

  double r1 = integral( &cub, -1, 1 );
  printf( "> %lf\n", r1 );

  return 0;
}
\end{Verbatim}

Այստեղ \texttt{ni.h} ֆայլը \texttt{prog11.c} ֆայլին կցված է
\Verb|#include| հրահանգով, բայց ֆայլի անունը նշելու համար
օգտագործված են ոչ թե \Verb|<| և \Verb|>| նիշերը, այլ սովորական
\Verb|"| չակերտները։ Երբ ֆայլի անունը վերցրած է \Verb|"|
չակերտների մեջ, Սի լեզվի նախապրոցեսորը այդ ֆայլը որոնում է
առաջին հերթին կոմպիլյացիայի պանակում։ Իսկ եթե օգտագործված են
\Verb|<| և \Verb|>| նիշերը, ապա որոնումը սկսվում է նախապես
որոշված տեղերից, որոնք համակարգում սահմանվում են կոմպիլյատորի
տեղադրման հետ։

\texttt{prog11.c} ֆայլը պետք է կոմպիլյացնել \texttt{ni.c}
ֆայլի հետ։ Օրինակ, հետևյալ հրամանով․

\begin{Verbatim}
$ clang -o prog11 ni.c prog11.c
\end{Verbatim}

Կամ, կարելի է երկու \Verb|*.c| ֆայլերը կոմպիլյացնել առանձին֊առանձին
ու ստանալ \emph{օբյեկտային} մոդուլները, ապա կապակցել դրանք ու ստանալ
կատարվող մոդուլը։ Օրինակ՝ այսպես․

\begin{Verbatim}
$ clang -c -o ni.o ni.c
$ clang -c -o prog11.o prog11.c
$ clang -o prog11 ni.o prog11.o
\end{Verbatim}

Ստացված \texttt{prog11} մոդուլը կատարելուց հետո կարտածվեն
\([-1;1]\) միջակայքում քառակուսային և խորանարդային ֆունկցիաների
ինտեգրալները։ Ահա այն ամբողջ ճանապարհը, որ պետք է անցնել կոդի
մակարդակով գրադարան ստեղծելու և օգտագործելու համար։

\tristar

Բայց միշտ չէ, որ հնարավոր է և պետք է գրադարանն օգտագործել կոդի
մակարդակում։ Ծրագրերի մշակման աշխարում գոյություն ունեն
գրադարանների ևս երկու հիմնական տեսակներ՝ \emph{ստատիկ կապակցվող}
և \emph{դինամիկ կապակցվող}։ Ծրագրում օգտագործելիս ստատիկ կապակցվող
գրադարանը «կապակցվում» է կատարվող մոդուլի հետ և դառնում է դրա
մասը։ Դինամիկ գրադարանը ծրագրում օգտագործելիս այն չի մտնում
կատարվող մոդուլի կազմի մեջ և բեռնվում է \emph{կատարման ժամանակ}։

Նախ ցույց տամ, թե ինչպես պետք է \texttt{ni.c} ֆայլից ստանալ
ստատիկ գրադարան։ Դրա համար պետք է ֆայլը կոմպիլյացնել և ստեղծել
\emph{օբյեկտային ֆայլ}, այնուհետև օբյեկտային ֆայլից (կամ ֆայլերից,
եթե դրանք մի քանի հատ են) ստանալ ստատիկ գրադարանի արխիվը։

Քիչ առաջ արդեն ցույց տվեցի, թե \Verb|.c| ֆայլը կոմպիլյացնելու
և համապատասխան օբյեկտային ֆայլը ստանալու համար ինչ հրաման պետք
է գրել։ (\texttt{gcc} և \texttt{clang} կոմպիլյատորների \Verb|-c|
պարամետրը թարգմանում է ծրագրի տեքստը օբյեկտային մոդուլի։)

\begin{Verbatim}
$ clang -c -o ni.o ni.c
\end{Verbatim}

Ստատիկ գրադարանի ֆայլը, որի անունը պետք է ունենա \texttt{lib}
նախածանցը, իսկ ընդլայնումը պետք է լինի \Verb|.a|, ստեղծվում է
\texttt{ar} արխիվացման ծրագրի օգնությամբ։

\begin{Verbatim}
$ ar rcs libni.a ni.o
\end{Verbatim}

Այս հրամանի հաջող կատարումով ստեղծվում է \texttt{libni.a}
ստատիկ կապակցվող գրադարանը։ Այդ գրադարանն օգտագործելու համար
պետք է ունենալ հայտարարությունների \texttt{ni.h} ֆայլը, և
գրադարանի իրականուցումը պարունակող \texttt{libni.a} ֆայլը։

Հիմա ենթադրենք ուզում եմ \texttt{prog11.c} ֆայլից ստանալ
կատարվող մոդուլ, օգտագործելով \texttt{libni.a} ստատիկ գրադարանը։
Դրա համար պետք է կոմպիլյատորի \Verb|-l| պարամետրով տալ գրադարանի
անունը՝ առանց \texttt{lib} նախածանցի և \Verb|.a| ընդլայնման,
ինչպես նաև \Verb|-static| պարամետրով նշել, որ կատարվելու է
ստատիկ կապակցում։

\begin{Verbatim}
$ gcc -o prog11 prog11.c -lni -static
\end{Verbatim}

Այս հրամանի կատարումից հետո արտածվում է հաղորդագրություն, որում
ասվում է, թե կապերի խմբագրիչը չի գտել \texttt{ni} գրադարանը։

\begin{Verbatim}
/usr/bin/ld: cannot find -lni
collect2: error: ld returned 1 exit status
\end{Verbatim}

Բանն այն է, որ \Verb|-l| պարամետրով նշված գրադարանները որոնվում
են կապերի խմբագրիչին (linker) նախապես հայտնի կոնկրետ տեղերում։
Որպեսզի որոնման ճանապարհներում ներառվեն նաև լրացուցիչ պանակներ,
դրանք պետք է թվարկել կոմպիլյացիայի (և կապակցման) հրամանի
\Verb|-L| պարամետրով։ Իմ օրինակում պարզապես պետք է նշել ընթացիկ
պանակը։

\begin{Verbatim}
$ gcc -o prog11 prog11.c -Լ. -lni -static
\end{Verbatim}

Արդեն կարող եմ գործարկել \texttt{prog11} մոդուլը և համոզվել,
որ այն աշխատում է իմ սպասածի պես։

\tristar

Անցնեմ առաջ ու պատմեմ դինամիկ (shared) գրադարան ստեղծելու մասին։
\emph{Դինամիկ} գրադարան ստեղծելու համար Սի լեզվի կոմպիլյատորին
պետք է հրահանգել, որ գեներացնի \emph{տեղաբաշխումից անկախ կոդով}
(position-independent code -- PIC) օբյեկտային ֆայլ։ Սա նշանակում
է, որ այդպիսի կոդը կարող է առանց փոփոխության կատարվել՝ բեռնվելով
հիշողության կամայական տիրույթում։ PIC կոդ գեներացնելու համար
կոմպիլյատորին պետք է տալ \Verb|-fpic| հրահանգը։ Ոչ PIC կոդով
օբյեկտային ֆայլից տարբերելու համար PIC կոդով օբյեկտային ֆայլին
հաճախ տալիս են \Verb|.lo| ընդլայնումը։

\begin{Verbatim}
$ gcc -c -fpic ni.c -o ni.lo
\end{Verbatim}

Այնուհետև \texttt{ni.lo} օբյեկտային ֆայլից պետք է կառուցել
\texttt{lib} նախածանց և \texttt{.so} ընդլայնում ունեցող դինամիկ
գրադարանի ֆայլը։

\begin{Verbatim}
$ gcc -shared -o libni.so ni.lo
\end{Verbatim}

Եթե այս հրամանի հաջող կատարումից հետո \texttt{ls} հրամանով արտածեմ
ընթացիկ պանակի պարունակությունը, կտեսնեմ, որ այնտեղ ստեղծվել է
\texttt{libni.so} մոդուլը։

\begin{Verbatim}
gcc -p prog11 prog11.c -L. -lni
\end{Verbatim}

\begin{Verbatim}
$ ./prog11
./prog11: error while loading shared libraries: libni.so: cannot open shared object file: No such file or directory
\end{Verbatim}

\begin{Verbatim}
export LD_LIBRARY_PATH=$(pwd):$LD_LIBRARY_PATH
\end{Verbatim}

\begin{Verbatim}
$ ./prog11
> 0.666667
> 0.000000
\end{Verbatim}
