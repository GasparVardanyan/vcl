\chapter{Ճյուղավորման կառուցվածք}

Նախորդ զրույցներում իմ բերած օրինակները շատ պարզ էին. ծրագիրը սկսվում
էր \code{main} ֆունկցիայից, կանչվում էր այս կամ այն ֆունկցիան, կատարվում
էին հաջորդական գործողություններ ու ծրագրի կատարումն ավարտվում էր։ Իսկ
ի՞նչ անել, երբ պետք է ծրագրի տրամաբանությունը ղեկավարել ներմուծված կամ
ձևավորված տվյալներից կախված։ Օրինակ, ինչպե՞ս սահմանեմ թվի նշանը որոշող
\code{sign} ֆունկցիան։ Այն պետք է արգումենտում ստացած դրական թվի
համար վերադարձնի՝ \code{1}, բացասականի համար՝ \code{-1}, իսկ զրոյի
համար՝ \code{0}։ Պարզ է, որ ֆունկցիայի այդպիսի վարքը մոդելավորելու համար  հարկավոր է որևէ \emph{ճյուղավորման} կառուցվածք։

Սի լեզվում ճյուղավորումները կազմակերպվում են \code{if}\index{if} հրամանով.

\begin{syntax}
if( \syte{condition} )
~~\syte{decision}
else
~~\syte{alternative}
\end{syntax}

Եթե \emph{ճշմարիտ} է \syte{condition} պայմանը, ապա կատարվում
են \syte{decision} հատվածի հրամանները, հակառակ դեպքում կատարվում
են \syte{alternative} հատվածի հրամանները։ Եթե պայմանի \emph{կեղծ}
լինելու դեպքում ոչինչ անել պետք չէ, ապա \code{else} ծառայողական բառը
և նրան հաջորդող \syte{alternative} հրամանները կարելի է չգրել։
Օրինակ, այսպես.

\begin{Verbatim}
if( argc == 1 )
  usage();
\end{Verbatim}

\code{usage} ֆունկցիան կանչվում է միայն այն դեպքում, երբ \code{argc}
փոփոխականը հավասար է մեկի։

Արդեն տեղին է հիշատակել C լեզվի համեմատման գործողությունների մասին։ Դրանք
վեցն են և նախատեսված են թվերի ու նիշերի համեմատման համար, իսկ \verb|==| և
\verb|!=| գործողությունները օգտագործվում են նաև ցուցիչների հավասարությունն
ու անհավասարությունը ստուգելու համար։

\begin{center}
\small
\begin{tabular}{c|l}
Գործողություն & Նշանակություն \\
\hline
== & հավասար է \\
!= & հավասար չէ \\
>  & մեծ է \\
>= & մեծ է կամ հավասար \\
<  & փոքր է \\
<= & փոքր է կամ հավասար \\
\end{tabular}
\end{center}

Հիմա վերը հիշատակված \code{sign} ֆունկցիայի մասին։ Այն կարող է ունենալ
հետևյալ տեսքը.

\begin{Verbatim}
int sign( double num )
{
  int res = 0; /* զրոյի դեպքը */
  if( num < 0 ) /* եթե բացասական է */
    res = -1;
  else if( num > 0 ) /* այլապես եթե դրական է */
    res = 1;
  return res;
}
\end{Verbatim}

Բայց, քանի որ \code{return} հրամանն իր կիրառման կետում ավարտում
է ֆունկցայի աշխատանքը, \code{sign} ֆունկցիան կարելի է գրել ավելի
պարզ ձևով։

\begin{Verbatim}
int sign( double num )
{
  if( num < 0 ) return -1; /* բացասական */
  if( num > 0 ) return 1;  /* դրական */
  return 0; /* զրո */
}
\end{Verbatim}

Ճյուղավորման հրամանը հնարավորություն է տալիս ծրագրում կազմակերպել
նաև կրկնություններ։ Օրինակ, տրված \code{x} թվի \code{y} աստիճանը
(երկուսն էլ ամբողջ թվեր են) հաշվող ֆունկցիան կարող եմ սահմանել
հետևյալ կերպ.

\begin{Verbatim}
int power( int x, int y )
{
  if( y == 0 )  /* թվի զրո աստիճանը */
    return 1;   /* 1 է */
  return x * power(x, y - 1); /* x^y = x * x^(y - 1) */
}
\end{Verbatim}

Այս ֆունկցիայում կրկնությունը մոդելավորված է \emph{ռեկուրսիայի}
\index{ռեկուրսիա} օգնությամբ. \code{x} թվի հերթական \code{y}
աստիճանը հաշվելու համար \code{x}-ը բազմապատկվում է իր \code{y-1}
աստիճանի արժեքի հետ։ Եթե որպես աստիճան տրված է \code{0}, ապա
վերադարձնում է \code{1}։

Մեկ այլ օրինակ՝ առանց ռեկուրսիայի օգտագործման։ \code{powers\_of\_two}
ֆունկցիան արգումենտում ստանում է \code{N} ամբողջ թիվը և ստանդարտ
արտածման հոսքին է արտածում \code{2}-ի \([0..N]\) աստիճանների աղյուսակը.

\begin{Verbatim}
void powers_of_two( int nm )
{
  int pw = 0;
cycle:
  printf("2^%d = %d\n", pw, 1 << pw);
  pw = pw + 1;
  if( pw <= nm ) goto cycle;
}
\end{Verbatim}

Այստեղ ցիկլի կազմակերպման համար ես օգտագործել եմ բազմաչարչար \code{goto}
\index{goto} հրամանը և մի \emph{նշիչ}, \emph{պիտակ} (label)։ Սի լեզվի
նշիչները իդենտիֆիկատորներ են, որոնցից հետո դրվում է \verb|:|։ Դրանք կարող
են գրվել ցանկացած հրամանից առաջ և օգտագործում են այդ հրամանին ուղղակի անցում
կատարելու համար։ \code{powers\_of\_two} ֆունկցիայի չորրորդ տողում գրված
է \code{cycle} նշիչը, որին յոթերորդ տողում գրված \code{goto} հրամանով
անցում է կատարվում այն դեպքում, երբ \code{pw}-ի արժեքը դեռևս փոքր է
\code{nm}-ի արժեքից։

Երկուսի հերթական \code{pw} աստիճանը հաշվարկվում է \code{1 << pw}
արտահայտությամբ (\code{printf} ֆունկցիայի երրորդ արգումենտում)։ Այս
\verb|<<| գործողությունը իր ձախ արգումենտի բիթերը դեպի ձախ է տեղաշարժում
աջ արգումենում տրված քանակով՝ ազատված դիրքերը լրացնելով զրոներով։

\medskip
Բացի \code{if-else} ճյուղավորման հրամանից, Սի լեզուն ունի նաև
\code{switch} \emph{ընտրության} հրամանը, որը թույլ է տալիս ընտրություն
կատարել հաստատուն մեծության արժեքներ մեջ և ամեն մի արժեքին համապատասխանեցնել
հրամանների առանձին հաջորդականություն։ Նրա ընդհանուր տեսքն այսպիսինն է.

\begin{syntax}
switch( \syte{expression} ) \{
~ case \ixte{value}{1}:
~   \ixte{block}{1}
~ case \ixte{value}{2}:
~   \ixte{block}{2}
~ ...
~ default:
~   \ixte{block}{def}
\}
\end{syntax}

\code{switch} հրամանի արգումենտի \syte{expression} արտահայտությունը
պետք է լինի ամբողջաթիվ կամ նիշային, իսկ \code{case}-ի արգումենտները՝
նույն տիպի հաստատուններ։ Եթե \syte{expression}-ի արժեքը \ixte{value}{1}
է, ապա կատարվում են \(\langle block_1\rangle\) խմբի հրամանները, եթե
\(\langle value_2\rangle\) է, ապա՝ \(\langle block_2\rangle\) հրամանները
և այդպես շարունակ։ Եթե \(\langle expression\rangle\)-ի արժեքը ոչ մի
\texttt{case} տարբերակի չի համընկնում, ապա կատարվում է \texttt{default}
ծառայողական բառից հետո գրված \(\langle block_{def}\rangle\) հրամանները։

Օրինակ, սահմանեմ \code{day\_of\_week} (շաբաթվա օր) ֆունկցիան, որն
արգումենտում ստանում է ամբողջ թիվ և արտածում է համապատասխան շաբաթվա
օրվա անունը։

\begin{Verbatim}
void day_of_week( int day )
{
  switch( day ) {
    case 1:
      puts( "երկուշաբթի" );
      break;
    case 2:
      puts( "երեքշաբթի" );
      break;
    case 3:
      puts( "չորեքշաբթի" );
      break;
    case 4:
      puts( "հինգշաբթի" );
      break;
    case 5:
      puts( "ուրբաթ" );
      break;
    case 6:
      puts( "շաբաթ" );
      break;
    case 7:
      puts( "կիրակի" );
      break;
    default:
      puts( "այդպիսի համարով օր չկա" );
  }
}
\end{Verbatim}

Պետք է ուշադրություն դարձնել, որ բոլոր \code{case} բլոկներն ավարտվում
են \code{break} հրամանով։ Բանն այն է, որ \code{switch} հրամանի մարմինը
հրամանների մի ընդհանուր հաջորդականություն է, իսկ \code{case} և
\code{default} հրամաններն այդ հաջորդականության մեջ ձևավորում են նշիչներ։
Երբ սկսվում է կատարվել բլոկներից որևէ մեկը, ապա կատարվում են \code{switch}
հրամանի մարմնի հաջորդ բոլոր հրամանները։ \code{break} հրամանը հնարավորություն
է տալիս կատարումն ընդհատել հարկավոր տեղում։

Օրինակ, սահմանեմ \code{working\_day} (աշխատանքային օր) ֆունկցիան, որը
\([1..5]\) օրերի համար արտածում է «աշխատանքային օր է» արտահայտությունը, իսկ
\code{6} և \code{7} օրերի համար՝ «հանգստյան օր է» արտահայտությունը։

\begin{Verbatim}
void working_day( int day )
{
  switch( day ) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      puts( "աշխատանքային օր է" );
      break;
    case 6:
    case 7:
      puts( "հանգստյան օր է" );
      break;
    default:
      puts( "այդպիսի համարով օր չկա" );
  }
}
\end{Verbatim}

Հետաքրքրության համար կարելի է հեռացնել \code{break} հրամանները և տեսնել,
թե ինչ կկատարվի։


\code{day\_of\_week} ֆունկցիան սահմանեմ նաև \code{if-else} հրամանի օգնությամբ.

\begin{Verbatim}
void day_of_week( int day )
{
  if( day == 1 )
    puts( "երկուշաբթի" );
  else if( day == 2 )
    puts( "երեքշաբթի" );
  else if( day == 3 )
    puts( "չորեքշաբթի" );
  else if( day == 4 )
    puts( "հինգշաբթի" );
  else if( day == 5 )
    puts( "ուրբաթ" );
  else if( day == 6 )
    puts( "շաբաթ" );
  else if( day == 7 )
    puts( "կիրակի" );
  else
    puts( "այդպիսի համարով օր չկա" );
}
\end{Verbatim}

Հերթով դիտարկվում են \code{day} արգումենտի արժեքները և ամեն մեկի համար
արտածվում է համապատասխան բառը։ Ամենավերջին \code{else} ճյուղը կատարվում
է այն դեպքում, երբ \code{day} փոփոխականի արժեքը \([1..7]\) միջակայքից չէ։
