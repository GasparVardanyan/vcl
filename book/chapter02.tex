\chapter{Փոփոխականներ}
\label{cha:variables}

\begin{epigraph}
Փոփոխականների հայտարաումը եւ սահմանումը, փոփոխականի
տիպը, փոփոխականին արժեքի վերագրումը, փոփոխականի հասցե,
ներմուծման ստանդարտ հոսքից տվյալների կարդալը։
\end{epigraph}

Սի լեզվով գրված ամեն մի ծրագիր, բացառությամբ պարզագույն դեպքերի,
պարունակում է փոփոխականներ։ \emph{Փոփոխականը}\index{փոփոխական}
մի օբյեկտ է, որը ծրագրի կատարման տարբեր պահերի կարող է պարունակել
նախապես որոշված ար\-ժեքների տիրույթի (domain) մի որևէ արժեք։
Յուրաքանչյուր փոփոխական, որ հանդիպում է ծրագրում, պետք է նախապես
\emph{սահմանված}\index{փոփոխական!սահմանում} լինի։ Փոփոխականի
սահմանումը բաղկացած է նրա \emph{տիպը}\index{փոփոխական!տիպ} որոշող
ծառայողական բառից և փոփո\-խականի \emph{անունից}։\index{փոփոխական!անուն}
Օրինակ.

\begin{Verbatim}
double a;      /* a-ն կրկնակի ճշտությամբ իրական թիվ է */
float b, c;    /* b-ն և c-ն սովորական ճշտության իրական թվեր են */
int d0, d1;    /* d0-ն և d1-ը ամբողջ թվեր են */
char sym;      /* sym-ը նիշ է (character) */
long int e1a;  /* e1a-ն երկար ամբողջ թիվ է */
\end{Verbatim}

Այստեղ \code{double}, \code{float}, \code{int}, \code{char} և
\code{long} բառերը \emph{ծառայողական բառեր} են և \emph{ներդրված}
տիպերի անուններ։ Իսկ \code{a}, \code{b}, \code{c}, \code{d0},
\code{d1}, \code{sym} և \code{e1a} բառերը իդենտիֆիկատորներ են։
Սի լեզվի \emph{իդենտիֆիկատորը} տառով կամ ընդգծման նիշով՝
«\code{\_}», սկսվող տառերի ու թվանշանների հաջորդականություն է։
Պետք է հիշել, որ Սի լեզվում մեծատառերն ու փոքրատառերը տարբերվում
են, այսինքն՝ \code{abc0} և \code{aBc0} բառերը տարբեր
իդենտիֆիկատորներ են։

Փոփոխականի տիպով որոշվում է հիշողությունում նրա զբաղեցրած բայթերի
քանակը և նրա հետ կատարվող թույլատրելի գործողությունները։ Օրինակ, իմ
համակարգում \code{int} տիպ ունեցող փոփոխականը զբաղեցնում է 4 բայթ,
\code{double} տիպ ունեցող փոփոխականը՝ 8 բայթ, իսկ \code{char} տիպի
փոփոխականը՝ 1 բայթ։ Ծրագրի կատարման ժամանակ փոփոխականի զբողեցրած
հիշողության չափը կարելի է ստանալ \code{sizeof} գործողության օգնությամբ։
Օրինակ, եթե \code{a0}-ն \code{double} տիպի փոփոխական է, ապա
\code{sizeof(a0)} արտհայտության արժեքը 8 է։ \code{sizeof}
գործողության արգումենտը կարող է լինել ոչ միայն փոփոխականի անուն,
այլ նաև Սի լեզվի տիպի անուն։ Օրինակ, \code{sizeof(unsigned int)}
արտահայտութ\-յան արժեքը առանց նշանի ամբողջ թվերը որոշող տիպի չափն է։

Որևէ կոնկրետ պլատֆորմում (սարքակազմ, օպերացիոն համակարգ, կոմպիլյատոր)
տիպերի չափն իմանալու համար կարելի է կատարել հետևյալ ծրագիրը.

\begin{Verbatim}
// prog02a.c
#include <stdio.h>

int main()
{
  printf("char = %ld, short = %ld, int = %ld, "
         "long = %ld, float = %ld, double = %ld\n",
         sizeof(char), sizeof(short), sizeof(int),
         sizeof(long), sizeof(float), sizeof(double));

  return 0;
}
\end{Verbatim}

Իմ համակարգում կատարում եմ հետևյալ հրամաններն ու ստանում եմ
արդյունքը.

\begin{Verbatim}
$ cc prog02a.c -o prog02a
$ ./prog02a
char = 1, short = 2, int = 4, long = 8, float = 4, double = 8
\end{Verbatim}

Պետք է հաշվի առնել, սակայն, որ Սի լեզվի ստանդարտը չի սահմանում
տիպերի չափերը։ Նշվում է միայն, որ \code{char}֊ը պետք է կունենա
նվազագույնը 8 բիթ երկարություն, \code{short}-ը և \code{int}֊ը՝
նվազագույնը 16 բիթ, իսկ \code{long}֊ը՝ նվազագույնը 32 բիթ։
Ինչպես նաև պետք է ճշմարիտ լինեն չափերի հետևյալ հարաբերությունները.

\[
\mathtt{sizeof(char)} \le
\mathtt{sizeof(short)} \le
\mathtt{sizeof(int)} \le
\mathtt{sizeof(long)}
\]
\[
\mathtt{sizeof(float)} \le
\mathtt{sizeof(double)}
\]

Փոփոխականին կարելի է արժեք վերագրել հենց անմիջապես հայտարարութ\-յան
ժամանակ։ Ընդհանրապես, ծրագրավորման «լավ ոճ» է համարվում, երբ փոփոխականին
արժեք է վերագրվում հայտարարության հետ միասին։ Օրինակ, հետևյալ հատվածում
հայտարարված են.

\begin{Verbatim}
int count = 0;       /* count ամբողջաթիվ փոփոխականը՝ 0 արժեքով */
double pi = 3.1415;  /* pi իրական փոփոխականը՝ 3.1415 արժեքով */
char c = 'A';        /* c նիշային փոփոխականը՝ «A» արժեքով */
\end{Verbatim}

Եթե \emph{լոկալ}\index{փոփոխական!լոկալ} փոփոխականին սկզբնական արժեք
տրված չէ, ապա կատարման ժամանակ այն կստանա իրեն հատկացված հիշողության
բջիջներում եղած պատահական արժեքը։ [Որոշ կոմպիլյատորներ զրոյացնում են
լոկալ փոփոխականների տիրույթը, բայց դա ստանդարտացված հատկություն չէ,
և չարժե հույս դնել դրա վրա։]

Փոփոխականին նոր արժեք է տրվում \code{=} \emph{վերագրման}
\index{փոփոխական!վերագրում} գործողությամբ։ Օրինակ.

\begin{Verbatim}
double a0, a1, b0;  /* a0-ն, a1-ը և b0-ն իրական թվեր են */
a0 = 2.36;          /* a0-ին վերագրել 2.36 */
a1 = 4.1;           /* a1-ին վերագրել 4.1 */
b0 = a0 + a1;       /* b0-ին վերագրել a0-ի և a1-ի գումարը */
\end{Verbatim}

Ծրագրի կատարման ժամանակ փոփոխականին հատկացված հիշողության տիրույթի
առաջին բայթի համարը փոփոխականի \emph{հասցեն}\index{փոփոխական!հասցե}
է, որը կարող ենք ստանալ \code{\&} միտեղանի (unary) գործողությամբ։
Օրինակ, \code{\&pi} արտհայտության արժեքը վերը սահմանված \code{pi}
փոփոխականի հասցեն է։

\marginpar{{\small նկար}}
\marginpar{{\small հասցեով արժեքի վերագրում}}


Ես ուզում եմ ցույց տալ ու մեկնաբանել մի ծրագիր, որն օգտագործողից
պահանջում է ներմուծել հարթության մի որևէ կետի դեկարտյան կոորդինատները և
արտածում է նույն այդ կետի բևեռային կոորդինատները։

Պարզ է, որ կետի դեկարտյան կոորդինատները ներկայացնելու համար պետք է
հայտարարել \code{x} և \code{y} իրական փոփոխականները, ապա դրանց
արժեքները կարդալ ստեղնաշարից։

\begin{Verbatim}
double x = 0.0, y = 0.0;
scanf("%lf", &x);  /* կարդալ իրական թիվ և վերագրել x-ին */
scanf("%lf", &y);  /* նույնը՝ y-ի համար */
\end{Verbatim}

Սի լեզվի ստանդարտ գրադարանի \code{scanf}\index{scanf} (scan formated
― ֆորմատավորված ընթերցում) ֆունկցիան ներմուծման ստանդարտ հոսքից (stdin)
կարդում է նիշերի հաջորդականություն և այն ձևափոխում է ըստ տրված ֆորմատի։
\code{scanf} ֆունկցիայի առաջին արգումենտը ֆորմատավորման տողն է, որ
կարող է պարունակել \code{\%} նիշով սկսվող ֆորմատավորման հրահանգներ։
\code{\%} նիշին հաջորդող նիշերով որոշվում է, թե ինչպես պետք է
մեկնաբանվեն կարդացած տվյալները։ Օրինակ, եթե գրված է \code{\%d}, ապա
սա նշանակում է, որ հոսքից կարդացած նիշերը պետք է դիտարկել որպես
տասական (decimal) թիվ։ Եթե գրված է \code{\%f}, ապա՝ սովորական ճշտության
իրական (float) թիվ։ Ֆորմատավորման հրահանգներին համապատասխան ձևափոխված
տվյալները գրվում են \code{scanf} ֆունկցիայի երկրորդ և հաջորդ արգումենտներով
տրված հասցեներում։ Օրինակ.

\begin{Verbatim}
scanf("%lf", &x);
\end{Verbatim}

արտահայտության մեջ տրված \code{"\%lf"} ֆորմատը նշում է, որ պետք է
կարդալ երկար իրական թիվ (l - long, f - float) և կարդացած արժեքը գրել
\code{x} փոփոխականի զբաղեցրած հասցեում։ \code{scanf} ֆունկցիային
փոխանցվում է ոչ թե փոփոխականը, այլ նրա հասցեն՝ այն տեղը, որտեղ պետք է
գրել կարդացած և ֆորմատավորած տվյալները։

\code{scanf} և \code{printf} ֆունկցիաների ֆորմատավորման հրահանգների
մասին ես դեռ պատմելու շատ առիթներ կունենամ։ Առայժմ բավական է իմանալ, որ
\code{"\%lf"} ֆորմատը կարդում է \code{double} արժեք։

\code{x} և \code{y} փոփոխականների արժեքները կարդացող \code{scanf}
ֆունկցիայի երկու կանչերը կարելի է միավորել մեկի մեջ՝ \code{"\%lf"}
ֆորմատը փոխարինելով \code{"\%lf,\%lf"} ֆորմատով։ Սա նշանակում է, որ
\code{scanf} ֆունկցիան ստեղնաշարից կարդալու է իրարից ստորակետով
բաժանված երկու \code{double} արժեք։

\begin{Verbatim}
double x = 0.0, y = 0.0;
/* կարդալ երկու իրական թվեր և վերագրել x-ին ու y-ին */
scanf("%lf,%lf", &x, &y);
\end{Verbatim}

Դե քանի որ \code{scanf} ֆունկցիայի ֆորմատավորման տողը պարունակում է
երկու ֆորմատավորման հրահանգ, ապա պետք է տալ կարդացած արժեքները գրելու
երկու տեղ՝ \code{\&x} և \code{\&y}։

Եթե պետք լինի օգտագործողին ստիպել, որ նա կետի կոորդինատները ներմուծի
\code{(} և \code{)} փակագծերի մեջ վերցրած, ապա կարելի է
ֆորմատավորման տողը գրել \code{"(\%lf,\%lf)"} տեսքով։ Բառացիորեն սա
կարելի է կարդալ հետևյալ կերպ. «\emph{կարդալ \code{(} նիշը, կարդալ
\code{double} թիվ, կարդալ \code{,} նիշը, կարդալ \code{double} թիվ,
կարդալ \code{)} նիշը}»։

Կետի \code{x} \emph{աբսցիսի} և \code{y} \emph{օրդինատի} արժեքները
կարդալուց հետո պետք է հաշվել նրա բևեռային կոորդինատները՝ \code{ρ}
\emph{շառավիղը} և \code{φ} \emph{ազիմուտը}։ Կոորդինատների բևեռային
համակարգում \code{ρ}-ն որոշվում է որպես կետի հեռավորությունն բևեռից,
իսկ \code{φ}-ն՝ որպես շառավղի և բևեռային առանցքի կազմած անկյուն։
Բևեռային շառավիղը որոշվում է Պյութագորասի թեորեմով՝ քանի որ այն իրենից
ներկայացնում է ուղղանկյուն եռանկյան ներքնաձիգ։ Բևեռային անկյունը
որոշելու համար էլ օգտվում ենք նույն ուղղանկյուն եռանկյունից և այն
փաստից, որ որոնելի անկյան տանգենսը հավասար է նրա դիմացի էջի երկարության
հարաբերությանը կից էջի երկարությանը՝ \code{y/x}, դե իսկ անկյան
մեծությունն էլ հավասար կլինի այդ վերջին հարաբերության արկտանգենսին։

![կոորդինատներ](nacl-fig-1.png)

Ասվածը C լեզվով կարող եմ գրել հետևյալ արտահայտություններով․

\begin{verbatim}
double rho = sqrt(x * x + y * y);
double phi = atan2(y, x);
\end{verbatim}

\code{sqrt} ֆունկցիան վերադարձնում է արգումենտի երկրորդ աստիճանի
արմատը, իսկ \code{atan2} ֆունկցիան վերադարձնում է \code{0} սկզբնակետ
և \code{(x,y)} վերջնակետ ունեցող վեկտորի և աբսցիցների առանցքի կազմած
անկյունը ռադիաններով։ Այս երկու ֆունկցիաներն էլ սահմանված են C լեզվի
ստանդարտ գրադարանի \code{math.h} ֆայլում։

\code{rho} և \code{phi} արժեքների հաշվարկից հետո պարզապես պետք է
արտածել դրանք․

\begin{verbatim}
puts( "Բևեռային կոորդնատներն են․ " );
printf( "ρ = %lf, φ = %lf\n", rho, phi );
\end{verbatim}

\code{printf} ֆունկցիայում նույնպես օգտագործվել են \code{"\%lf"}
ֆորմատավորման հրահանգները։ Քանի որ \code{printf} ֆունկցիան իր
արգումենտները չի փոխում, այստեղ նրան փոխանցում ենք \code{x} և
\code{y} փոփոխականների արժեքները, այլ ոչ թե հասցեները։

Վերջ։ Մնում է այս ամենը հավաքել \code{main} ֆունկցիայի մեջ,
կոմպիլյացնել, գործարկել ու տեսնել արդյունքները։ Ես ամբողջ ծրագիրը գրել
եմ \code{prog02.c} ֆայլի մեջ։

\begin{verbatim}
#include <stdio.h>
#include <math.h>

int main()
{
  double x = 0.0, y = 0.0;
  puts( "Ներմուծիր դեկարտյան կոորդինատները x,y․ " );
  scanf( "%lf,%lf", &x, &y );

  double rho = sqrt( x * x + y * y );
  double phi = atan2( y, x );

  puts( "Բևեռային կոորդնատներն են․ " );
  printf( "ρ = %lf, φ = %lf\n", rho, phi );

  return 0;
}
\end{verbatim}

\code{\#include} դիրեկտիվով կցվել են \code{stdio.h} և
\code{math.h} ֆայլերը։ Առաջինից օգտագործվում են \code{puts},
\code{scanf} և \code{printf} ֆունկցիաները, իսկ երկրորդից՝
\code{sqrt} և \code{atan2} ֆունկցիաները։

Երբ ես փորձում եմ \code{prog02.c} ֆայլը կոմպիլյացնել այնպես, ինչպես դա
արեցի առաջին զրույցում նկարագրված \code{prog01.c} ֆայլի հետ.

\begin{verbatim}
$ clang prog02.c -o prog2
\end{verbatim}

ապա ստանում եմ մի հաղորդագրություն, որն ասում է, թե linker ծրագիրը՝
\emph{կապերի խմբագրիչը}, չի գտել \code{sqrt} և \code{atan2}
ֆունկցիաները։

\begin{verbatim}
/tmp/prog02-80b543.o: In function `main':
prog02.c:(.text+0x6a): undefined reference to `sqrt'
prog02.c:(.text+0x91): undefined reference to `atan2'
clang: error: linker command failed with exit code 1 (use -v to see invocation)
\end{verbatim}

Բանն այն է, որ \code{math.h} ֆայլը պարունակում է մաթեմատիկական
գրադարանի հայտարարությունները, բայց ոչ սահմանումները։ Սահմանումները,
այսինքն մաթեմատիկական գրադարանի կոմպիլյացված օբյեկտային կոդը, գտնվում է
\code{libm.a} (ստատիկ) և \code{libm.so} (դինամիկ) օբյեկտային
ֆայլերում։ ՈՒրեմն, երբ ծրագրի ֆայլում \code{\#include} դիրեկտիվով
կցում ենք \code{math.h} ֆայլը, դա անում ենք, պարզպես, որ կոմպլյատորն
իմանա օգտագործվող ֆունկցիաների հայտարարությունները։ Իսկ կապերի խմբագրման
(link) ժամանակ, երբ պետք է ստացվի կատարվող ֆայլ, կոմպիլյատորի
\code{-l} պարամետրով պիտի տալ \code{m} գրադարանը (գրադարանների
անունները սկսվում են lib նախածանցով, բայց \code{-l} պարամետրով
գրադարանը նշելիս lib-ը չի գրվում)։

\code{prog02.c} ֆայլի կոմպիլյացիայի՝ վերը բերված հրամանն իրականում
կատարվում է չորս քայլով՝ \emph{նախամշակում} (preprocessing),
\emph{կոմպիլյացիա} (compilation), \emph{ասեմբլացում} (assembly) և
\emph{կապակցում} (linking)։ Նախամշակման փուլում մշակվում են \code{\#}
նիշով սկսվող հրահանգները. \code{\#include} հրահանգով կցվում են ֆայլեր,
\code{\#define} հրահանգով սահմանվում են մակրոսներ և այլն (նախամշակման
քայլի մասին մանրամասն կխոսեմ քիչ ավելի ուշ)։ Կոմպիլյացիայի փուլում C
լեզվով գրված ծրագիրը թարգմանվում է ասեմբլերի լեզվով գրված ծրագրի։
Ասեմբլացման փուլում ասեմբլերի լեզվով ծրագիրը թարգմանվում է կոնկրետ
ապարատային պլատորմի վրա աշխատող կոնկրետ օպերացիոն համակարգի օբյեկտային
կոդի։ Կապակցման փուլում իրար են կցվում առանձին-առանձին կոմպիլյացված
օբյեկտային մոդուլները, ստեղծվում է կատարվող մոդուլ։ Եթե ուզում ես
տեսնել, թե այդ միջանկյալ քայլերում ինչ ֆայլեր են գեներացվում, ապա կարող
ես կոմպիլյացիայի հրամանին տալ \verb|--save-temps| պարամետրը.

\begin{verbatim}
$ clang --save-temps -o prog02 prog02.c -lm
\end{verbatim}

Այս հրամանի կատարումից հետո ստեղծվում են \code{prog02.i},
\code{prog02.s}, \code{prog02.o}, \code{prog02} ֆայլերը։ Դրանք
համապատասխանաբար նախամշակման, կոմպիլյացիայի և ասեմբլացման փուլերում
ստեղծված ֆայլերն են։ Կապակցման արդյունքում ստացված ֆայլը ստանում է
կոմպիլյատորի ՝-օ՝ պարամետրով տրված անունը։

Կոմպիլյացիայի քայլերը ես էլ կարող եմ առանձնացնել։

\begin{enumerate}
\item \code{clang -E -o prog02.i prog02.c} --- Նախամշակել, բայց
  չկոմպիլյացնել։ Ստեղծվում է \code{prog02.i} ֆայլը։
\item \code{clang -S -o prog02.s prog02.i} --- Կոմպիլյացնել նախամշակված
  ֆայլը, բայց չասեմբլացնել։ Ստեղծվում է \code{prog02.s} ֆայլը։
\item \code{clang-3.5 -c -o prog02.o prog02.s} --- Ասեմբլերային ֆայլը
  թարգմանել օբյեկտային ֆայլի։ Ստեղծվում է \code{prog02.o} ֆայլը։
\item \code{clang -o prog02 prog02.o -lm} --- Օբյեկտային ֆայլը կապակցել
  գրադարանների հետ և ստեղծել \code{prog02} կատարվող մոդուլը։
\end{enumerate}

Հիմա արդեն ամեն ինչ կարգին է․ ֆայլը թարգմանվել է և կառուցվել է
\code{prog02} կատարվող ֆայլը։ Գործարկեմ այն ու տեսնեմ, թե ինչ է
ստացվում․

\begin{verbatim}
$ ./prog02
Ներածիր դեկարտյան կոորդինատները x,y․
3,2
Բևեռային կոորդնատներն են․
ρ = 3.605551, φ = 0.588003
\end{verbatim}

Հենց որ ծրագիրն առաջարկում է ներածել \code{x} և \code{y} դեկարտյան
կոորդինատները, ես ներածում եմ \code{3,2} թվերը։ Դրան ի պատասխան
ծրագիրն արտածել է \code{ρ\ =\ 3.605551} և \code{φ\ =\ 0.588003}
արժեքները։

Այս զրույցի համար էլ այսքանը։ Հաջորդ զրույցում կպատմեմ ֆունկցիաների
սահմանման, դրանց արգումենտների ու վերադարձրած արժեքի մասին։
