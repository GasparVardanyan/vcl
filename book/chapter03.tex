\chapter{Ֆունկցիաներ}

\begin{epigraph}
Ֆունկցիաների հայտարարումն ու սահմանումը, ֆունկցիայի արգումենտներն
ու վերադարձրած արժեքը, ֆունկցիայի հասցե։
\end{epigraph}

Ինչպես և մաթեմատիկայում, որտեղից եկել է \emph{ֆունկցիա}
\index{ֆունկցիա} տերմինը, այնպես էլ Սի լեզվում ֆունկցիաները
նախատեսված են տվյալների մի բազմությունը մեկ այլ բազմության
արտապատկերելու համար։ Օրինակ, Զրույց \ref{cha:variables}-ում
հիշատակված \code{sqrt}\index{sqrt} ֆունկցիան արգումենտում սպասում
է \code{double} (\(\mathbb{R}\)) տիպի արժեք և վերադարձնում է այդ
արժեքի երկրորդ աստիճանի արմատը՝ նորից \code{double} տիպի արժեք։
Ասում են, որ \code{sqrt} ֆունկցիան \code{double} արժեքների բազմությունն
արտապատկերում է նույն \code{double} արժեքների բազմությանը։ Մաթեմատիկորեն
այդ փաստը սովորաբար գրառվում է հետևյալ կերպ․

\[
\mathrm{sqrt}: \mathbb{R}\mapsto\mathbb{R}
\]

Իսկ Սի լեզվով այս նույն \emph{հայտարարությունը}\index{ֆունկցիա!հայտարարություն} գրառվում է այսպես․

\begin{Verbatim}
double sqrt(double);
\end{Verbatim}

Մեկ այլ օրինակ է նորից Զրույց \ref{cha:variables}-ում հիշատակված
\code{atan2}\index{atan2} ֆունկցիան։ Այն արգումենտում սպասում է
երկու \code{double} թվեր՝ կետի կոորդինատները և վերադարձնում է աբսցիսների
առանցքի և կոորդինատների սկզբնակետով ու տրված կետով անցնող ուղղի կազմած
անկյունը՝ նորից \code{double} թիվ՝ \((−\pi, \pi]\) միջակայքից։
Մաթեմատիկական գրառումը կարող է լինել այսպիսին․

\[
\mathrm{atan2}: \mathbb{R}\times\mathbb{R}\mapsto(−\pi, \pi]
\]

Սի լեզվով գրառումն էլ այսպիսինն է․

\begin{Verbatim}
double atan2(double, double);
\end{Verbatim}

[Ցավոք Սի լեզուն թույլ չի տալիս արժեքի տիպի համար ավելի խիստ
սահմանափակումներ գրել։ Տվյալ դեպքում մենք հնարավորություն չունենք
նշելու, որ \code{atan2} ֆունկցիայից վերադարձվող \emph{իրական}
արժեքը պետք է ընկած լինի \((−\pi, \pi]\) միջակայքում։]

Եվ այսպես, Սի ծրագրավորման լեզվում ֆունկցիայի հայտարարությունն ունի
երեք բաղադրիչ. \emph{վերադարձվող արժեքի տիպ}, \emph{ֆունկցիայի անուն}
և \emph{պարամետրերի տիպերի ցուցակ}։ Վերադարձվող արժեքի տիպը և
պարամետրերի տիպն իրար հետ կոչվում է \emph{ֆունկցիայի տիպ}։

\begin{center}
\begin{picture}(74,18)
\put(0,14){\texttt{double atan2(double, double);}}
\put(8,4){\vector(0,1){9}}
\put(0,0){\textsf{\scriptsize արժեքի տիպը}}
\put(24,8){\vector(0,1){5}}
\put(20,5){\textsf{\scriptsize անունը}}
\put(34,13){\line(1,0){34}}
\put(50,8){\vector(0,1){5}}
\put(36,6){\textsf{\scriptsize պարամետրերի տիպերը}}
\end{picture}
\end{center}

Երբեմն ֆունկցիայի տիպ են անվանում վրա վերադարձրած արժեքի տիպը։
Բնականաբար դա սխալ է, որովհետև միայն վերադարձվող արժեքի տիպը չի
կարող միարժեքորեն բնորոշել ֆունկցիան։

Փոփոխականների պես ֆունկցիաներն էլ պետք է օգտագործումից առաջ հայտարարել։
Բայց Սի լեզվում հայտարարելուց բացի պետք է նաև \emph{սահմանել}
\index{ֆունկցիա!սահմանում} ֆունկցիաների վարքը՝ տալ այն գործողությունները,
որ ֆունկցիան կատարում է \emph{որոշման տիրույթն} \emph{արժեքների տիրույթին}
արտապատկերելու համար։ Ֆունկցիայի վարքը սահմանող բլոկը կոչվում է
\emph{ֆունկցիայի մարմին}\index{ֆունկցիա!մարմին} և որոշվում է
\emph{վերնագրից} հետո գրված ու \verb|{|, \verb|}| փակագծերի մեջ առնված
հրամանների հաջորդականությամբ։

Սահմանենք ֆունկցիա, որը հաշվում ու վերադարձնում է տրված \(r\) շառավղով
և տրված \(\rho\) խտությամբ նյութից պատրաստված գնդի զանգվածը։ Հիշենք, որ
մարմնի զանգվածը դրա ծավալի և խտության արտադրյալն է, իսկ գնդի ծավալը
հաշվվում է շառավղից կախված հետևյալ բանաձևով.

\[
V(r) = \frac{4}{3}\pi r^3։
\]

Հետևաբար գնդի զանգվածն արտահայտող բանաձևը, որ կախված է գնդի շառավղից
ու նյութի խտությունից, կունենա այսպիսի տեսք.

\[
W(r,\rho)=\rho \frac{4}{3}\pi r^3։
\]

Այս բանաձևը ծրագրավորելու համար սահմանենք երկու իրական արգումենտներով 
և իրական արժեք վերադարձնող \verb|weight_of_ball| ֆունկցիան.

\begin{Verbatim}
/* գնդի զանգվածի հաշվումը */
double weight_of_ball(double ragius, double density)
{
  const double PI = 3.141592;
  return density * 4 / 3 * PI * radius * radius * radius;
}
\end{Verbatim}


Օրինակ, նախորդ զրույցում դեկարտյան
կոորդինատներից բևեռային կոորդինատները ստանալու համար օգտագործեցի երկու
բանաձև՝ կետի շառավիղը և ազիմուտը հաշվող կանոնները։ Կարող եմ սահմանել,
օրինակ, \code{radius} ֆունկցիան հետևյալ կերպ․

\begin{Verbatim}
/* շառավղի հաշվումը դեկարտյան կոորդինատներով */
double radius(double x, double y)
{
  return sqrt(x * x + y * y);
}
\end{Verbatim}

Սի լեզվի \code{return}\index{return} հրամանը ֆունկցիայից արժեք
վերադարձնող գործողությունն է։ Այն իր կիրառման կետում ավարտում է
ֆունկցիայի կատարումը և ծրագրի ղեկավարումը փոխանցում է տվյալ ֆունկցիայի
կանչի կետին հաջորդող հրամանին։ Յուրաքանչյուր ֆունկցիա պարտավոր է ունենալ
գոնե մեկ \code{return} հրաման և այդ հրամանի արգումենտն էլ հենց
ֆունկցիայի արժեքն է։

\code{radius} ֆունկցիայի պես կարող եմ սահմանել նաև \code{azimuth}
ֆունկցիան․

\begin{Verbatim}
/* ազիմուտի հաշվումը դեկարտյան կոորդինատներով */
double azimuth(double x, double y)
{
  return atan2(y, x);
}
\end{Verbatim}

Այս օրինակներից երևում է, որ, ի տարբերություն ֆունկցիայի հայտարարության,
ֆունկցիայի սահմանման ժամանակ վերնագրում պետք է գրել ոչ թե պարամետրերի տիպերի
ցուցակը, այլ պարամետրերի հայտարարությունների ցուցակը։ Սակայն, եթե ծրագրում
\code{x}, \code{y} և \code{z} փոփոխականները թույլատրելի է հայտարարել
մեկ հրամանով՝

\begin{Verbatim}
float x, y, z;
\end{Verbatim}

ապա ֆունկցիայի սահմանման ժամանակ այդպիսի բան գրել չի կարելի․

\begin{Verbatim}
? int f(int x, y, z)
? {
?   return x + y + z;
? }
\end{Verbatim}

Ամեն մի պարամետրի անունից առաջ պետք է գրել իր տիպը։ Այսպես․

\begin{Verbatim}
int f(int x, int y, int z)
{
  return x + y + z;
}
\end{Verbatim}

Կարծում եմ արդեն պարզ է, որ Սի լեզվի ֆունկցիաները հնարավորություն են տալիս
ամբողջությամբ մոդելավորել ֆունկցիայի մաթեմատիկական գաղափարը։ Բայց ծրագրավորման
գործում հաճախ հանդիպում են դեպքեր, երբ մեզ չի հետաքրքրում ֆունկցիայի
վերադարձրած արժեքը, կամ ֆունկցիան ընդհանրապես վերադարձվող արժեք չունի։ Այդ
դեպքերում Սի լեզուն առաջարկում է ֆունկցիայի վերադարձվող արժեքի տիպը նշել
\code{void}\index{code} ծառայողական բառով։ Օրինակ, կարող եմ սահամանել մի
ֆունկցիա, որն \code{stdout}\index{stdout} հոսքին է արտածում իմ անունը.

\begin{Verbatim}
void my_name()
{
  puts("Ընկ. Ա. Բադալյան");
}
\end{Verbatim}

Այս ֆունկցիան արգումենտներ չի ստանում և արժեք չի վերադարձնում. այն
պարզապես կատարում է նախապես որոշված ինչ-որ գործ։ Հաճախ \code{void}
վերադարձրած արժեքի տիպ ունեցող ֆունկցիային անվանում են
\emph{պրոցեդուրա}։\index{պրոցեդուրա}

\code{scanf}\index{scanf} ֆունկցիայի մասին պատմելիս ասացի, որ այն,
ըստ իր առաջին արգումենտում տրված ֆորմատի, կարդում է արժեքներ և գրում
է ֆորմատավորման հրահանգներին համապատասխան երկրորդ և հաջորդ արգումենտներով
տրված \emph{հասցեներում}։\index{փոփոխական!հասցե} Հիմա ուզում եմ պատմել,
թե ինչպես են օգտագործվում փոփոխականների հասցեները։

Եթե ուզում եմ ծրագրում հայտարարել, որ պատրաստվում եմ \code{a0} փոփոխականին
վերագրել ամբողջ թվեր, իսկ \code{a1} փոփոխականին՝ նիշեր, ապա պետք է գրեմ.

\begin{Verbatim}
int a0 = 777;
char a1 = 'A';
\end{Verbatim}

Եթե ուզում եմ հայտարարել, որ \code{p0} փոփոխականին վերագրելու եմ ամբողջաթիվ
փոփոխականի հասցե, իսկ \code{p1} փոփոխականին՝ նիշային փոփոխականի հասցե,
ապա պետք է գրեմ․

\begin{Verbatim}
int* p0 = &a0;   /* p0 ցուցիչը արժեքավորել a0-ի հասցեով */
char* p1 = &a1;  /* p1 ցուցիչը արժեքավորել a1-ի հասցեով */
\end{Verbatim}

Փոփոխականի հայտարարման այս նոր գրելաձևը, երբ տիպի անունից հետո գրված
է \verb|*| նիշը, հենց \emph{ցուցիչ} փոփոխականի հայտարարման ձևն է (իսկ
\verb|&| գործողությունը փոփոխականի հասցեն վերցնելու գործողությունն է)։

Հիմա կարող եմ \code{a0} և \code{a1} փոփոխականներին արժեք վերագրել ոչ թե
ուղղակիորեն, այլ նրանց հասցեի միջոցով։ Օրինակ այսպես․

\begin{Verbatim}
*p0 = 888;  /* a0-ին վերագրել 888 */
*p1 = 'B';  /* a1-ին վերագրել 'B' */
\end{Verbatim}

Այս դեպքում արդեն \verb|*| գործողությունը կոչվում է \emph{ապահասցեավորման}
գործողություն (ի հակադրություն \verb|&| գործողության, որը \emph{հասցեավորման}
գործողությունն է)։

Հիմա, երբ արդեն գիտեմ, որ կարող եմ ֆունկցիային տալ փոփոխականի հասցեն և
ֆունկցիան էլ կարող է իր հաշվարկած արժեքները գրել այս հասցեում, կսահմանեմ
մի նոր ֆունկցիա, որը, ստանալով կետի դեկարտյան կոորդինատները, վերադարձնում
է նույն այդ կետի բևեռային կոորդինատները։ Բայց վերադարձնում է ոչ թե որպես
ֆունկցիայի արժեք, այլ հաշվարկած արժեքները գրում է տրված հասցեներում։

\begin{Verbatim}
void polar(double x, double y, double* rho, double* phi)
{
  *rho = sqrt(x * x + y * y);
  *phi = atan2(y, x);
}
\end{Verbatim}

\code{polar} ֆունկցիան ստանում է երկու իրական թիվ, որոնք ֆունկցիայի
արգումենտներն են, և իրական թվերի երկու ցուցիչներ, որոնք, ըստ էության,
ֆունկցիայի վերադարձվող արժեքներն են։ Այս նոր ֆունկցիան օգտագործվում է
ճիշտ այնպես, ինչպես օգտագործվում էր \code{scanf} ֆունկցիան՝ ստեղնաշարից
կոորդինատների կարդալու ժամանակ․

\begin{Verbatim}
double x = 0.0, y = 0.0;
scanf("%lf,%lf", &x, &y);

double rho = 0.0, phi = 0.0;
polar(x, y, &rho, &phi);
\end{Verbatim}

Քանի որ \code{polar} ֆունկցիան արժեքները վերադարձնում է որպես ցուցիչ
տրված արգումենտների միջոցով, պետք է սահմանման մեջ նշել, որ այս ֆունկցիան
սովորական իմաստով վերադարձվող արժեք չունի և չի օգտագործելու \code{return}
հրամանը։ Ես դա արել եմ ֆունկցիայի տիպը նշելով որպես \code{void}։


Ծրագրի առանձին, տրամաբանորեն անկախ հատվածները ֆունկցիաների տեսքով
կազմակերպելով կարծես թե ստեղծում ենք խաղալիք կոնստրուկտորի մասնիկները,
որոնցից հետո հավաքելու ենք պետք եղած օբյեկտը՝ ծրագիրը։ Բացի այդ,
հնարավորություն ենք ստեղծում առանձին֊առանձին \emph{թեստավորել} այդ
հատվածները։

\marginpar{Ֆունկցիայի հասցեի մասին}

Սի ծրագրավորման լեզուն թույլ է տալիս սահմանել ֆունկցիաներ՝ առանց նշելու
դրանց պարամետրերի ճիշտ քանակը։ Այդպիսի ֆունկցիաների պարամետրերի ցուցակը
պետք է բաղկացած լինի գոնե մեկ հայտարարված պարամետրից և բազմակետերից։
Օրինակ, արդեն հիշատակված \code{scanf} և \code{printf} ֆունկցիաների
հայտարարությունը մոտավորապես հետևյալն է․

\begin{Verbatim}
int scanf(const char* format, ...);
int printf(const char* format, ...);
\end{Verbatim}

Ստանդարտ գրադարանի \code{stdarg.h} ֆայլում հայտարարված են բոլոր այն
անհրաժեշտ միջոցները, որոնց օգնությամբ սահմանվում են \emph{վարիադիկ}
ֆունկցիաները։

Ֆունկցիաների մասին առայժմ այսքանը։ Բայց սա դեռ ամբողջը չէ։
